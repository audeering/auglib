

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>auglib.core.transform &mdash; Documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.png"/>
  
  
  

  

  
  
    

  
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/audeering.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    
  

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          <a href="../../../index.html">
          
            <img src="../../../_static/images/audeering.png" class="logo" alt="audEERING"/>
          
          
            <span> auglib</span>
          
          </a>

          
            
            
              <div class="version">
                v1.0.4
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../external.html">External Solutions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/auglib.html">auglib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/auglib.observe.html">auglib.observe</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/auglib.transform.html">auglib.transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/auglib.utils.html">auglib.utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">auglib</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>auglib.core.transform</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for auglib.core.transform</h1><div class="highlight"><pre>
<span></span><span class="c1"># This module contains all transforms.</span>
<span class="c1"># As ``audobject`` uses the path inside the Python package</span>
<span class="c1"># during serialization,</span>
<span class="c1"># they should never be moved to a different file,</span>
<span class="c1"># and the file should never be renamed.</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span>

<span class="kn">import</span> <span class="nn">audeer</span>
<span class="kn">import</span> <span class="nn">audiofile</span>
<span class="kn">import</span> <span class="nn">audmath</span>
<span class="kn">import</span> <span class="nn">audobject</span>
<span class="kn">import</span> <span class="nn">audresample</span>

<span class="kn">from</span> <span class="nn">auglib.core</span> <span class="kn">import</span> <span class="n">observe</span>
<span class="kn">from</span> <span class="nn">auglib.core.resolver</span> <span class="kn">import</span> <span class="n">ArrayResolver</span>
<span class="kn">from</span> <span class="nn">auglib.core.resolver</span> <span class="kn">import</span> <span class="n">ObservableListResolver</span>
<span class="kn">from</span> <span class="nn">auglib.core.seed</span> <span class="kn">import</span> <span class="n">get_seed</span>
<span class="kn">from</span> <span class="nn">auglib.core.time</span> <span class="kn">import</span> <span class="n">Time</span>
<span class="kn">from</span> <span class="nn">auglib.core.utils</span> <span class="kn">import</span> <span class="n">from_db</span>
<span class="kn">from</span> <span class="nn">auglib.core.utils</span> <span class="kn">import</span> <span class="n">get_peak</span>
<span class="kn">from</span> <span class="nn">auglib.core.utils</span> <span class="kn">import</span> <span class="n">rms_db</span>
<span class="kn">from</span> <span class="nn">auglib.core.utils</span> <span class="kn">import</span> <span class="n">to_db</span>
<span class="kn">from</span> <span class="nn">auglib.core.utils</span> <span class="kn">import</span> <span class="n">to_samples</span>


<span class="n">__doctest_skip__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;AMRNB&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Append&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AppendValue&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BabbleNoise&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BandPass&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BandStop&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Clip&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ClipByRatio&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Compose&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CompressDynamicRange&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Fade&quot;</span><span class="p">,</span>
    <span class="s2">&quot;FFTConvolve&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Function&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GainStage&quot;</span><span class="p">,</span>
    <span class="s2">&quot;HighPass&quot;</span><span class="p">,</span>
    <span class="s2">&quot;LowPass&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Mask&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Mix&quot;</span><span class="p">,</span>
    <span class="s2">&quot;NormalizeByPeak&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PinkNoise&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Prepend&quot;</span><span class="p">,</span>
    <span class="s2">&quot;PrependValue&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Resample&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Select&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Shift&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Tone&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Trim&quot;</span><span class="p">,</span>
    <span class="s2">&quot;WhiteNoiseGaussian&quot;</span><span class="p">,</span>
    <span class="s2">&quot;WhiteNoiseUniform&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">DTYPE</span> <span class="o">=</span> <span class="s2">&quot;float32&quot;</span>
<span class="n">SUPPORTED_FADE_SHAPES</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;tukey&quot;</span><span class="p">,</span>
    <span class="s2">&quot;kaiser&quot;</span><span class="p">,</span>
    <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
    <span class="s2">&quot;exponential&quot;</span><span class="p">,</span>
    <span class="s2">&quot;logarithmic&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">SUPPORTED_FILL_STRATEGIES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;zeros&quot;</span><span class="p">,</span> <span class="s2">&quot;loop&quot;</span><span class="p">]</span>
<span class="n">SUPPORTED_FILL_POSITIONS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">]</span>
<span class="n">SUPPORTED_FILTER_DESIGNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;butter&quot;</span><span class="p">]</span>
<span class="n">SUPPORTED_TONE_SHAPES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;sine&quot;</span><span class="p">,</span> <span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="s2">&quot;triangle&quot;</span><span class="p">,</span> <span class="s2">&quot;sawtooth&quot;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">get_noise_gain_from_snr</span><span class="p">(</span><span class="n">rms_signal_db</span><span class="p">,</span> <span class="n">rms_noise_db</span><span class="p">,</span> <span class="n">snr_db</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Translates requested SNR to gain of noise signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        rms_signal_db: root mean square of signal in dB</span>
<span class="sd">        rms_noise_db: root mean square of noise signal</span>
<span class="sd">            with max amplitude in dB</span>
<span class="sd">        snr_db: desired signal-to-noise ration in dB</span>

<span class="sd">    Returns:</span>
<span class="sd">        gain to be applied to noise signal</span>
<span class="sd">            to achieve desired SNR in dB</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># SNR = RMS_signal^2 / (gain * RMS_noise)^2</span>
    <span class="c1"># =&gt; SNR_dB = 10 log10(RMS_signal^2 / (gain * RMS_noise)^2)</span>
    <span class="c1"># =&gt; SNR_dB = 10 log10(RMS_signal^2) - 10 log10((gain * RMS_noise)^2)</span>
    <span class="c1"># =&gt; SNR_dB = 20 log10(RMS_signal) - 20 log10(gain * RMS_noise)</span>
    <span class="c1"># =&gt; SNR_dB = 20 log10(RMS_signal) - 20 log10(gain) - 20 log10(RMS_noise)</span>
    <span class="c1"># =&gt; SNR_dB = RMS_signal_dB - gain_dB - RMS_noise_dB</span>
    <span class="n">gain_db</span> <span class="o">=</span> <span class="n">rms_signal_db</span> <span class="o">-</span> <span class="n">rms_noise_db</span> <span class="o">-</span> <span class="n">snr_db</span>
    <span class="k">return</span> <span class="n">gain_db</span>


<div class="viewcode-block" id="Base"><a class="viewcode-back" href="../../../api/auglib.transform.Base.html#auglib.transform.Base">[docs]</a><span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">audobject</span><span class="o">.</span><span class="n">Object</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Base class for transforms applied to a signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        unit: unit of any duration values</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        aux: auxiliary signal,</span>
<span class="sd">            file,</span>
<span class="sd">            or signal generating transform.</span>
<span class="sd">            If a transform is given</span>
<span class="sd">            it will be applied</span>
<span class="sd">            to an empty signal with the same length</span>
<span class="sd">            as the signal</span>
<span class="sd">            that will be augmented</span>
<span class="sd">        transform: transformation applied to the auxiliary signal</span>
<span class="sd">        num_repeat: number of repetitions</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@audobject</span><span class="o">.</span><span class="n">init_decorator</span><span class="p">(</span>
        <span class="n">resolvers</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;aux&quot;</span><span class="p">:</span> <span class="n">ArrayResolver</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="s2">&quot;Base&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="s2">&quot;Base&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num_repeat</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bypass_prob</span> <span class="o">=</span> <span class="n">bypass_prob</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preserve_level</span> <span class="o">=</span> <span class="n">preserve_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aux</span> <span class="o">=</span> <span class="n">aux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_repeat</span> <span class="o">=</span> <span class="n">num_repeat</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>  <span class="c1"># pragma: no cover</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Transform a signal.</span>

<span class="sd">        Args:</span>
<span class="sd">            signal: audio signal</span>
<span class="sd">            aux: auxiliary signal</span>
<span class="sd">            sampling_rate: sampling rate of ``signal`` and ``aux`` in Hz</span>

<span class="sd">        Raises:</span>
<span class="sd">            NotImplementedError: raised if not overwritten in child class</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="Base.__call__"><a class="viewcode-back" href="../../../api/auglib.transform.Base.html#auglib.transform.Base.__call__">[docs]</a>    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply transform to signal.</span>

<span class="sd">        Args:</span>
<span class="sd">            signal: signal to be transformed</span>
<span class="sd">            sampling_rate: sampling rate in Hz</span>

<span class="sd">        Returns:</span>
<span class="sd">            augmented signal</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the signal shape</span>
<span class="sd">                is not support</span>
<span class="sd">                by chosen transform parameters</span>
<span class="sd">            ValueError: if ``sampling_rate`` is ``None``,</span>
<span class="sd">                but the transform requires a samling rate</span>
<span class="sd">            RuntimeError: if the given sampling rate is incompatible</span>
<span class="sd">                with the transform</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bypass_prob</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bypass_prob</span><span class="p">)</span>
        <span class="n">preserve_level</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preserve_level</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bypass_prob</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">bypass_prob</span><span class="p">:</span>
            <span class="c1"># (sample) =&gt; (channel, samples)</span>
            <span class="n">ndim</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">signal</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">DTYPE</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">DTYPE</span><span class="p">)</span>

            <span class="c1"># Ensure signal is not read-only</span>
            <span class="c1"># (https://github.com/audeering/auglib/issues/31)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">signal</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;WRITEABLE&quot;</span><span class="p">]:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">preserve_level</span><span class="p">:</span>
                <span class="n">signal_level</span> <span class="o">=</span> <span class="n">rms_db</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

            <span class="n">num_repeat</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_repeat</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_repeat</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">aux</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
                        <span class="n">signal</span><span class="p">,</span>
                        <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aux</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aux</span><span class="p">)</span>

                    <span class="c1"># aux is file</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">aux</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">audiofile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>

                    <span class="c1"># aux is signal generating transform</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">Base</span><span class="p">):</span>
                        <span class="n">generator</span> <span class="o">=</span> <span class="n">aux</span>
                        <span class="n">channels</span><span class="p">,</span> <span class="n">samples</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span>
                        <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">channels</span><span class="p">,</span> <span class="n">samples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">)</span>
                        <span class="n">aux</span> <span class="o">=</span> <span class="n">generator</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>

                    <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">aux</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">aux</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">DTYPE</span><span class="p">:</span>
                        <span class="n">aux</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">DTYPE</span><span class="p">)</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span>
                        <span class="n">signal</span><span class="p">,</span>
                        <span class="n">aux</span><span class="p">,</span>
                        <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">preserve_level</span><span class="p">:</span>
                <span class="n">mix_level</span> <span class="o">=</span> <span class="n">rms_db</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
                <span class="n">gain</span> <span class="o">=</span> <span class="n">from_db</span><span class="p">(</span><span class="n">signal_level</span> <span class="o">-</span> <span class="n">mix_level</span><span class="p">)</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">signal</span>

            <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">signal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># (channel, sample) =&gt; (sample)</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">signal</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">DTYPE</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">DTYPE</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>

<div class="viewcode-block" id="Base.to_samples"><a class="viewcode-back" href="../../../api/auglib.transform.Base.html#auglib.transform.Base.to_samples">[docs]</a>    <span class="k">def</span> <span class="nf">to_samples</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">],</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert duration value to samples.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">to_samples</span><span class="p">(</span>
            <span class="n">value</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
            <span class="n">allow_negative</span><span class="o">=</span><span class="n">allow_negative</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<div class="viewcode-block" id="AMRNB"><a class="viewcode-back" href="../../../api/auglib.transform.AMRNB.html#auglib.transform.AMRNB">[docs]</a><span class="k">class</span> <span class="nc">AMRNB</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Encode-decode signal using AMRNB codec.</span>

<span class="sd">    Adaptive Multi Rate - Narrow Band (AMRNB) speech codec.</span>
<span class="sd">    A lossy format used in 3rd generation mobile telephony</span>
<span class="sd">    and defined in 3GPP TS 26.071 et al.</span>

<span class="sd">    The input signal needs to have a sampling rate of 8000 Hz.</span>

<span class="sd">    Args:</span>
<span class="sd">        bit_rate: target bit rate of the encoded stream in bits per second.</span>
<span class="sd">            Supported bit rates:</span>
<span class="sd">            4750, 5150, 5900, 6700, 7400, 7950, 10200, 12200.</span>
<span class="sd">            Any positive bit rate is allowed,</span>
<span class="sd">            but will be converted</span>
<span class="sd">            to the closest supported one.</span>
<span class="sd">        dtx: enable discontinuous transmission (DTX)</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.AMRNB(7400)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(</span>
<span class="sd">            ...     &quot;emodb&quot;,</span>
<span class="sd">            ...     &quot;wav/03a01Fa.wav&quot;,</span>
<span class="sd">            ...     version=&quot;1.4.1&quot;,</span>
<span class="sd">            ...     sampling_rate=8000,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-amrnb0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                8000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-amrnb0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bit_rate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">dtx</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bit_rate</span> <span class="o">=</span> <span class="n">bit_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtx</span> <span class="o">=</span> <span class="n">dtx</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sampling_rate</span> <span class="o">!=</span> <span class="mi">8000</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;AMRNB requires a sampling rate of 8000 Hz. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;You have </span><span class="si">{</span><span class="n">sampling_rate</span><span class="si">}</span><span class="s2"> Hz.&quot;</span>
            <span class="p">)</span>
        <span class="n">bit_rate</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bit_rate</span><span class="p">)</span>
        <span class="n">dtx</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtx</span><span class="p">)</span>

        <span class="c1"># ffmpeg requires libavcodec-extra57 under Ubuntu</span>
        <span class="c1"># (which install also libvo-amrwbenc0)</span>
        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmp</span><span class="p">:</span>
            <span class="n">infile</span> <span class="o">=</span> <span class="n">audeer</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;infile.wav&quot;</span><span class="p">)</span>
            <span class="n">outfile</span> <span class="o">=</span> <span class="n">audeer</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;outfile.amr&quot;</span><span class="p">)</span>
            <span class="n">audiofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;ffmpeg&quot;</span><span class="p">,</span>
                <span class="s2">&quot;-i&quot;</span><span class="p">,</span>
                <span class="n">infile</span><span class="p">,</span>
                <span class="s2">&quot;-b:a&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="n">bit_rate</span><span class="p">),</span>
                <span class="s2">&quot;-dtx&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">dtx</span><span class="p">)),</span>
                <span class="n">outfile</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">audiofile</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
            <span class="n">signal</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">audiofile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
                <span class="n">outfile</span><span class="p">,</span>
                <span class="n">always_2d</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="Append"><a class="viewcode-back" href="../../../api/auglib.transform.Append.html#auglib.transform.Append">[docs]</a><span class="k">class</span> <span class="nc">Append</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Append an auxiliary signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        aux: auxiliary signal,</span>
<span class="sd">            file,</span>
<span class="sd">            or signal generating transform.</span>
<span class="sd">            If a transform is given</span>
<span class="sd">            it will be applied</span>
<span class="sd">            to an empty signal with the same shape</span>
<span class="sd">            as the signal</span>
<span class="sd">            the transform is applied to</span>
<span class="sd">        read_pos_aux: read position of auxiliary signal (see ``unit``)</span>
<span class="sd">        read_dur_aux: duration to read from auxiliary signal</span>
<span class="sd">            (see ``unit``).</span>
<span class="sd">            Set to ``None`` or ``0`` to read the whole signal</span>
<span class="sd">        unit: literal specifying the format of ``read_pos_aux`` and</span>
<span class="sd">            ``read_dur_aux`` (see :meth:`auglib.utils.to_samples`)</span>
<span class="sd">        transform: transformation applied to the auxiliary signal</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Append coughing at the end of a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(</span>
<span class="sd">            ...     &quot;cough-speech-sneeze&quot;,</span>
<span class="sd">            ...     &quot;coughing/kopzxumj430_40.94-41.8.wav&quot;,</span>
<span class="sd">            ...     version=&quot;2.0.1&quot;,</span>
<span class="sd">            ...     sampling_rate=16000,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; cough, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Append(cough)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-append0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-append0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">read_pos_aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">read_dur_aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Base</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">aux</span><span class="o">=</span><span class="n">aux</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pos_aux</span> <span class="o">=</span> <span class="n">read_pos_aux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_dur_aux</span> <span class="o">=</span> <span class="n">read_dur_aux</span> <span class="ow">or</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_pos_aux</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">read_pos_aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_pos_aux</span><span class="p">,</span>
                <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">read_pos_aux</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_dur_aux</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">read_dur_aux</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">read_pos_aux</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">read_dur_aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_dur_aux</span><span class="p">,</span>
                <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">signal</span><span class="p">,</span> <span class="n">aux</span><span class="p">[:,</span> <span class="n">read_pos_aux</span> <span class="p">:</span> <span class="n">read_pos_aux</span> <span class="o">+</span> <span class="n">read_dur_aux</span><span class="p">]],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="AppendValue"><a class="viewcode-back" href="../../../api/auglib.transform.AppendValue.html#auglib.transform.AppendValue">[docs]</a><span class="k">class</span> <span class="nc">AppendValue</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Expand signal with a constant value.</span>

<span class="sd">    Args:</span>
<span class="sd">        duration: duration of signal with constant value</span>
<span class="sd">            that will be appended</span>
<span class="sd">            (see ``unit``)</span>
<span class="sd">        value: value to append</span>
<span class="sd">        unit: literal specifying the format of ``duration``</span>
<span class="sd">            (see :meth:`auglib.utils.to_samples`).</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Append zeros at the end of a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.AppendValue(8000, value=0, unit=&quot;samples&quot;)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-append-value0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-append-value0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">],</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">duration</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                <span class="n">duration</span><span class="p">,</span>
                <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="o">*</span> <span class="n">samples</span><span class="p">])</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">Append</span><span class="p">(</span><span class="n">aux</span><span class="p">)(</span><span class="n">signal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="BabbleNoise"><a class="viewcode-back" href="../../../api/auglib.transform.BabbleNoise.html#auglib.transform.BabbleNoise">[docs]</a><span class="k">class</span> <span class="nc">BabbleNoise</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Adds Babble Noise.</span>

<span class="sd">    Babble noise refers to having several speakers</span>
<span class="sd">    in the background</span>
<span class="sd">    all talking at the same time.</span>

<span class="sd">    :class:`BabbleNoise` does not use built-in speech signals</span>
<span class="sd">    but expects a sequence of speech signals or files</span>
<span class="sd">    as ``speech`` argument,</span>
<span class="sd">    from which it then randomly samples the speech.</span>

<span class="sd">    Args:</span>
<span class="sd">        speech: speech signal(s) used to create babble noise</span>
<span class="sd">        num_speakers: number of speech signals</span>
<span class="sd">            used to create babble noise.</span>
<span class="sd">            If not enough speech signals are given</span>
<span class="sd">            it will repeat all</span>
<span class="sd">            or some of them</span>
<span class="sd">        gain_db: gain in decibels.</span>
<span class="sd">            Ignored if ``snr_db`` is not ``None``</span>
<span class="sd">        snr_db: signal-to-noise ratio in decibels</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Pure babble noise.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; auglib.seed(1)</span>
<span class="sd">            &gt;&gt;&gt; db = audb.load(&quot;musan&quot;, media=&quot;.*speech-librivox-000\d&quot;, version=&quot;1.0.0&quot;)</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.BabbleNoise(db.files[:5])</span>
<span class="sd">            &gt;&gt;&gt; signal = np.zeros((1, 30372))</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-babble-noise0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-babble-noise0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Add babble noise consisting of 5 speakers to a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; auglib.seed(1)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-babble-noise1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-babble-noise1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="nd">@audobject</span><span class="o">.</span><span class="n">init_decorator</span><span class="p">(</span>
        <span class="n">resolvers</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;speech&quot;</span><span class="p">:</span> <span class="n">ObservableListResolver</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">speech</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">num_speakers</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">gain_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">snr_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speech</span> <span class="o">=</span> <span class="n">speech</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_speakers</span> <span class="o">=</span> <span class="n">num_speakers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span> <span class="o">=</span> <span class="n">gain_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span> <span class="o">=</span> <span class="n">snr_db</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># First create signal containing babble noise</span>
        <span class="c1"># by summing speech signals</span>
        <span class="n">babble</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">)</span>
        <span class="n">num_repeat</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_speakers</span><span class="p">)</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">Mix</span><span class="p">(</span>
            <span class="n">observe</span><span class="o">.</span><span class="n">List</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speech</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">gain_aux_db</span><span class="o">=</span><span class="n">to_db</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">num_repeat</span><span class="p">),</span>
            <span class="n">num_repeat</span><span class="o">=</span><span class="n">num_repeat</span><span class="p">,</span>
            <span class="n">loop_aux</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="c1"># Cycle the input signal</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">Shift</span><span class="p">(</span>
                <span class="n">observe</span><span class="o">.</span><span class="n">FloatUni</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">babble</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">babble</span><span class="p">)</span>
        <span class="c1"># Mix the babble noise to aux signal</span>
        <span class="n">transform</span> <span class="o">=</span> <span class="n">Mix</span><span class="p">(</span>
            <span class="n">babble</span><span class="p">,</span>
            <span class="n">gain_aux_db</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span><span class="p">,</span>
            <span class="n">snr_db</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;samples&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="BandPass"><a class="viewcode-back" href="../../../api/auglib.transform.BandPass.html#auglib.transform.BandPass">[docs]</a><span class="k">class</span> <span class="nc">BandPass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Run signal through a band-pass filter.</span>

<span class="sd">    Args:</span>
<span class="sd">        center: center frequency in Hz</span>
<span class="sd">        bandwidth: bandwidth frequency in Hz</span>
<span class="sd">        order: filter order</span>
<span class="sd">        design: filter design,</span>
<span class="sd">            at the moment only ``&#39;butter&#39;`` is available</span>
<span class="sd">            corresponding to a Butterworth filter</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if ``design`` contains a non-supported value</span>

<span class="sd">    Examples:</span>
<span class="sd">        Filter a speech signal with a 1000 Hz bandwidth,</span>
<span class="sd">        centered at 2000 Hz.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.BandPass(center=2000, bandwidth=1000)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-band-pass0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-band-pass0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Inspect its magnitude spectrum.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audmath</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; sigs = [signal, augmented_signal]</span>
<span class="sd">            &gt;&gt;&gt; colors = [&quot;#5d6370&quot;, &quot;#e13b41&quot;]</span>
<span class="sd">            &gt;&gt;&gt; for sig, color in zip(sigs, colors):</span>
<span class="sd">            ...     magnitude, f = plt.mlab.magnitude_spectrum(sig, Fs=sampling_rate)</span>
<span class="sd">            ...     # Smooth magnitude</span>
<span class="sd">            ...     magnitude = np.convolve(magnitude, np.ones(14) / 14, mode=&quot;same&quot;)</span>
<span class="sd">            ...     plt.plot(f, audmath.db(magnitude), color=color)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlim([10, 8000])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylim([-100, -45])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylabel(&quot;Magnitude / dB&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlabel(&quot;Frequency / Hz&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.legend([&quot;signal&quot;, &quot;augmented signal&quot;])</span>
<span class="sd">            &gt;&gt;&gt; plt.grid(alpha=0.4)</span>
<span class="sd">            &gt;&gt;&gt; sns.despine()</span>
<span class="sd">            &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="n">bandwidth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">design</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;butter&quot;</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span> <span class="o">=</span> <span class="n">bandwidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">if</span> <span class="n">design</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_FILTER_DESIGNS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown filter design &#39;</span><span class="si">{</span><span class="n">design</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="s2">&quot;Supported designs are: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SUPPORTED_FILTER_DESIGNS</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">=</span> <span class="n">design</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sampling_rate is &#39;None&#39;, but required.&quot;</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
        <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="n">lowcut</span> <span class="o">=</span> <span class="n">center</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">highcut</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;butter&quot;</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span>
                <span class="n">order</span><span class="p">,</span>
                <span class="p">[</span><span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">],</span>
                <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;bandpass&quot;</span><span class="p">,</span>
                <span class="n">fs</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">DTYPE</span><span class="p">)</span></div>


<div class="viewcode-block" id="BandStop"><a class="viewcode-back" href="../../../api/auglib.transform.BandStop.html#auglib.transform.BandStop">[docs]</a><span class="k">class</span> <span class="nc">BandStop</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Run signal through a band-stop filter.</span>

<span class="sd">    Args:</span>
<span class="sd">        center: center frequency in Hz</span>
<span class="sd">        bandwidth: bandwidth frequency in Hz</span>
<span class="sd">        order: filter order</span>
<span class="sd">        design: filter design,</span>
<span class="sd">            at the moment only ``&#39;butter&#39;`` is available</span>
<span class="sd">            corresponding to a Butterworth filter</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if ``design`` contains a non-supported value</span>

<span class="sd">    Examples:</span>
<span class="sd">        Filter a speech signal with a 3000 Hz hole,</span>
<span class="sd">        centered at 2000 Hz.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.BandStop(center=2000, bandwidth=3000)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-band-stop0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-band-stop0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Inspect its magnitude spectrum.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audmath</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; sigs = [signal, augmented_signal]</span>
<span class="sd">            &gt;&gt;&gt; colors = [&quot;#5d6370&quot;, &quot;#e13b41&quot;]</span>
<span class="sd">            &gt;&gt;&gt; for sig, color in zip(sigs, colors):</span>
<span class="sd">            ...     magnitude, f = plt.mlab.magnitude_spectrum(sig, Fs=sampling_rate)</span>
<span class="sd">            ...     # Smooth magnitude</span>
<span class="sd">            ...     magnitude = np.convolve(magnitude, np.ones(14) / 14, mode=&quot;same&quot;)</span>
<span class="sd">            ...     plt.plot(f, audmath.db(magnitude), color=color)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlim([10, 8000])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylim([-100, -45])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylabel(&quot;Magnitude / dB&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlabel(&quot;Frequency / Hz&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.legend([&quot;signal&quot;, &quot;augmented signal&quot;])</span>
<span class="sd">            &gt;&gt;&gt; plt.grid(alpha=0.4)</span>
<span class="sd">            &gt;&gt;&gt; sns.despine()</span>
<span class="sd">            &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">center</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="n">bandwidth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">design</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;butter&quot;</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span> <span class="o">=</span> <span class="n">bandwidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">if</span> <span class="n">design</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_FILTER_DESIGNS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown filter design &#39;</span><span class="si">{</span><span class="n">design</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="s2">&quot;Supported designs are: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SUPPORTED_FILTER_DESIGNS</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">=</span> <span class="n">design</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sampling_rate is &#39;None&#39;, but required.&quot;</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
        <span class="n">bandwidth</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bandwidth</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="n">lowcut</span> <span class="o">=</span> <span class="n">center</span> <span class="o">-</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">highcut</span> <span class="o">=</span> <span class="n">center</span> <span class="o">+</span> <span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;butter&quot;</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span>
                <span class="n">order</span><span class="p">,</span>
                <span class="p">[</span><span class="n">lowcut</span><span class="p">,</span> <span class="n">highcut</span><span class="p">],</span>
                <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;bandstop&quot;</span><span class="p">,</span>
                <span class="n">fs</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">DTYPE</span><span class="p">)</span></div>


<div class="viewcode-block" id="Clip"><a class="viewcode-back" href="../../../api/auglib.transform.Clip.html#auglib.transform.Clip">[docs]</a><span class="k">class</span> <span class="nc">Clip</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Hard/soft-clip the signal.</span>

<span class="sd">    ``threshold`` sets the amplitude level in decibels</span>
<span class="sd">    to which the signal is clipped.</span>
<span class="sd">    The optional argument ``soft``</span>
<span class="sd">    triggers a soft-clipping behaviour,</span>
<span class="sd">    for which the whole waveform</span>
<span class="sd">    is warped through a cubic non-linearity,</span>
<span class="sd">    resulting in a smooth transition</span>
<span class="sd">    between the flat (clipped) regions</span>
<span class="sd">    and the rest of the waveform.</span>

<span class="sd">    Args:</span>
<span class="sd">        threshold: amplitude level</span>
<span class="sd">            above which samples will be clipped</span>
<span class="sd">            (in decibels)</span>
<span class="sd">        soft: apply soft-clipping</span>
<span class="sd">        normalize: after clipping normalize signal to 0 decibels</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Clip a speech signal at -10 dB.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Clip(threshold=-10)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-clip0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-clip0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">soft</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">soft</span> <span class="o">=</span> <span class="n">soft</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
        <span class="n">soft</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
        <span class="n">normalize</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">)</span>

        <span class="c1"># Clip</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">from_db</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="o">-</span><span class="n">threshold</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

        <span class="c1"># Cubic warping for soft clip</span>
        <span class="k">if</span> <span class="n">soft</span><span class="p">:</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">threshold</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">threshold</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">threshold</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="n">signal</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">*</span> <span class="p">(</span><span class="n">signal</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">NormalizeByPeak</span><span class="p">(</span><span class="n">peak_db</span><span class="o">=</span><span class="mi">0</span><span class="p">)(</span><span class="n">signal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="ClipByRatio"><a class="viewcode-back" href="../../../api/auglib.transform.ClipByRatio.html#auglib.transform.ClipByRatio">[docs]</a><span class="k">class</span> <span class="nc">ClipByRatio</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Hard/soft-clip a certain fraction of the signal.</span>

<span class="sd">    Rather than receiving a specific amplitude threshold,</span>
<span class="sd">    this function is designed to get instructed</span>
<span class="sd">    about the number of samples</span>
<span class="sd">    that are meant to be clipped,</span>
<span class="sd">    in relation to the total length of the signal.</span>
<span class="sd">    This ratio is internally translated</span>
<span class="sd">    into the amplitude threshold</span>
<span class="sd">    needed for achieving the specified intensity</span>
<span class="sd">    of the degradation.</span>
<span class="sd">    The optional argument ``soft``</span>
<span class="sd">    triggers a soft-clipping behaviour,</span>
<span class="sd">    for which the whole waveform is warped</span>
<span class="sd">    through a cubic non-linearity,</span>
<span class="sd">    resulting in a smooth transition</span>
<span class="sd">    between the flat (clipped) regions</span>
<span class="sd">    and the rest of the waveform.</span>

<span class="sd">    Args:</span>
<span class="sd">        ratio: ratio between the number of samples that are to be clipped</span>
<span class="sd">            and the total number of samples in the signal</span>
<span class="sd">        soft: apply soft-clipping</span>
<span class="sd">        normalize: after clipping normalize signal to 0 decibels</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Clip 5% of the samples of a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.ClipByRatio(0.05)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-clip-by-ratio0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-clip-by-ratio0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ratio</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">soft</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">soft</span> <span class="o">=</span> <span class="n">soft</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">)</span>
        <span class="n">soft</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
        <span class="n">normalize</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ratio</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">signal</span>

        <span class="c1"># Find threshold by ordering peak levels</span>
        <span class="c1"># and selecting based on the ratio</span>
        <span class="n">samples_to_clip</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ratio</span> <span class="o">*</span> <span class="n">signal</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">samples_to_clip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">clip_level</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">clip_level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">signal</span>

        <span class="n">signal</span> <span class="o">=</span> <span class="n">Clip</span><span class="p">(</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">to_db</span><span class="p">(</span><span class="n">clip_level</span><span class="p">),</span>
            <span class="n">soft</span><span class="o">=</span><span class="n">soft</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
        <span class="p">)(</span><span class="n">signal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="Compose"><a class="viewcode-back" href="../../../api/auglib.transform.Compose.html#auglib.transform.Compose">[docs]</a><span class="k">class</span> <span class="nc">Compose</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compose several transforms together.</span>

<span class="sd">    Args:</span>
<span class="sd">        transforms: list of transforms to compose</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Append a cough to a speech signal,</span>
<span class="sd">        and then add pink noise and clipping to the whole signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; auglib.seed(0)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(</span>
<span class="sd">            ...     &quot;cough-speech-sneeze&quot;,</span>
<span class="sd">            ...     &quot;coughing/kopzxumj430_40.94-41.8.wav&quot;,</span>
<span class="sd">            ...     version=&quot;2.0.1&quot;,</span>
<span class="sd">            ...     sampling_rate=16000,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; cough, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Compose(</span>
<span class="sd">            ...     [</span>
<span class="sd">            ...         auglib.transform.Append(cough),</span>
<span class="sd">            ...         auglib.transform.PinkNoise(snr_db=10),</span>
<span class="sd">            ...         auglib.transform.ClipByRatio(0.02),</span>
<span class="sd">            ...     ],</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-compose0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-compose0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Add pink noise and clipping to a speech signal,</span>
<span class="sd">        and afterwards append coughing.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Compose(</span>
<span class="sd">            ...     [</span>
<span class="sd">            ...         auglib.transform.PinkNoise(snr_db=10),</span>
<span class="sd">            ...         auglib.transform.ClipByRatio(0.02),</span>
<span class="sd">            ...         auglib.transform.Append(cough),</span>
<span class="sd">            ...     ],</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-compose1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-compose1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Add pink noise and clipping to a cough,</span>
<span class="sd">        and append it to a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Append(</span>
<span class="sd">            ...     cough,</span>
<span class="sd">            ...     transform=auglib.transform.Compose(</span>
<span class="sd">            ...         [</span>
<span class="sd">            ...             auglib.transform.PinkNoise(snr_db=10),</span>
<span class="sd">            ...             auglib.transform.ClipByRatio(0.02),</span>
<span class="sd">            ...         ],</span>
<span class="sd">            ...     ),</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-compose2.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-compose2.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transforms</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">transform</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="CompressDynamicRange"><a class="viewcode-back" href="../../../api/auglib.transform.CompressDynamicRange.html#auglib.transform.CompressDynamicRange">[docs]</a><span class="k">class</span> <span class="nc">CompressDynamicRange</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compress the dynamic range.</span>

<span class="sd">    The dynamic range of the signal</span>
<span class="sd">    is compressed</span>
<span class="sd">    by attenuating any sample</span>
<span class="sd">    whose amplitude exceeds a certain ``threshold_db``.</span>
<span class="sd">    The intensity of the attenuation</span>
<span class="sd">    is determined</span>
<span class="sd">    by the ``ratio`` parameter</span>
<span class="sd">    (the higher the ratio, the stronger the gain reduction).</span>
<span class="sd">    To avoid heavy distortion,</span>
<span class="sd">    the gain reduction is smoothed over time with a contour</span>
<span class="sd">    that is governed by the ``attack_time``</span>
<span class="sd">    and the ``release_time`` parameters.</span>

<span class="sd">    The input-output characteristic</span>
<span class="sd">    also features a non-linear region (&quot;knee&quot;)</span>
<span class="sd">    around the threshold.</span>
<span class="sd">    The width of this region</span>
<span class="sd">    is controlled by the ``knee_radius_db`` parameter</span>
<span class="sd">    (expressed in decibels, and in absolute value):</span>
<span class="sd">    the nonlinear region is entered</span>
<span class="sd">    when the input signal exceeds a level</span>
<span class="sd">    given by ``threshold_db - kneeRadius_db``,</span>
<span class="sd">    hence some gain reduction</span>
<span class="sd">    can be also seen before hitting the main threshold,</span>
<span class="sd">    if the knee radius is greater than zero.</span>

<span class="sd">    Optionally,</span>
<span class="sd">    the resulting signal</span>
<span class="sd">    can be amplified (linearly)</span>
<span class="sd">    by means of the ``makeup_db`` gain parameter</span>
<span class="sd">    (expressed in decibels).</span>
<span class="sd">    Sample values can also be clipped</span>
<span class="sd">    to the interval ``[-1.0, 1.0]``</span>
<span class="sd">    when exceeding this range:</span>
<span class="sd">    this behaviour is achieved</span>
<span class="sd">    by setting the ``clip`` argument.</span>

<span class="sd">    .. note:: Setting ``makeup_db`` to ``None``</span>
<span class="sd">        triggers a special behaviour,</span>
<span class="sd">        for which the makeup gain is computed automatically</span>
<span class="sd">        in a way that the peak level of the processed signal</span>
<span class="sd">        is equal to the original peak level</span>
<span class="sd">        (before compression).</span>

<span class="sd">    Args:</span>
<span class="sd">        threshold_db: threshold in decibels</span>
<span class="sd">        ratio: ratio (the higher the ratio, the stronger the gain reduction)</span>
<span class="sd">        attack_time: attack time in seconds</span>
<span class="sd">        release_time: release time in seconds</span>
<span class="sd">        makeup_db: optional amplification gain</span>
<span class="sd">        clip: clip signal</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Attenuate all samples of a speech signal</span>
<span class="sd">        above -15 dB by a factor of 4.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.CompressDynamicRange(-15, 1 / 4)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-compress-dynamic-range0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-compress-dynamic-range0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">threshold_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="n">ratio</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">attack_time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">release_time</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.02</span><span class="p">,</span>
        <span class="n">knee_radius_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">,</span>
        <span class="n">makeup_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">clip</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold_db</span> <span class="o">=</span> <span class="n">threshold_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratio</span> <span class="o">=</span> <span class="n">ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attack_time</span> <span class="o">=</span> <span class="n">attack_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release_time</span> <span class="o">=</span> <span class="n">release_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knee_radius_db</span> <span class="o">=</span> <span class="n">knee_radius_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">makeup_db</span> <span class="o">=</span> <span class="n">makeup_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip</span> <span class="o">=</span> <span class="n">clip</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sampling_rate is &#39;None&#39;, but required.&quot;</span><span class="p">)</span>

        <span class="n">threshold_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold_db</span><span class="p">)</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ratio</span><span class="p">)</span>
        <span class="n">attack_time</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attack_time</span><span class="p">)</span>
        <span class="n">release_time</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">release_time</span><span class="p">)</span>
        <span class="n">knee_radius_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">knee_radius_db</span><span class="p">)</span>
        <span class="n">peak_db</span> <span class="o">=</span> <span class="n">to_db</span><span class="p">(</span><span class="n">get_peak</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">makeup_db</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">makeup_db</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">normalize_db</span> <span class="o">=</span> <span class="n">peak_db</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">makeup_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">makeup_db</span><span class="p">)</span>
            <span class="n">normalize_db</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">clip</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clip</span><span class="p">)</span>

        <span class="c1"># As values would be clipped by sox</span>
        <span class="c1"># when writing to the file,</span>
        <span class="c1"># we need to adjust the level</span>
        <span class="c1"># for clip=False</span>
        <span class="k">if</span> <span class="n">clip</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">peak_db</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">NormalizeByPeak</span><span class="p">(</span><span class="n">peak_db</span><span class="o">=</span><span class="mi">0</span><span class="p">)(</span><span class="n">signal</span><span class="p">)</span>
                <span class="n">threshold_db</span> <span class="o">=</span> <span class="n">threshold_db</span> <span class="o">-</span> <span class="n">peak_db</span>
                <span class="k">if</span> <span class="n">normalize_db</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">normalize_db</span> <span class="o">=</span> <span class="n">peak_db</span>

        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmp</span><span class="p">:</span>
            <span class="n">infile</span> <span class="o">=</span> <span class="n">audeer</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;infile.wav&quot;</span><span class="p">)</span>
            <span class="n">outfile</span> <span class="o">=</span> <span class="n">audeer</span><span class="o">.</span><span class="n">path</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;outfile.wav&quot;</span><span class="p">)</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;sox&quot;</span><span class="p">,</span>
                <span class="n">infile</span><span class="p">,</span>
                <span class="n">outfile</span><span class="p">,</span>
                <span class="s2">&quot;compand&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">attack_time</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">release_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">knee_radius_db</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">threshold_db</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">ratio</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">threshold_db</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="n">audiofile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>
            <span class="n">audiofile</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
            <span class="n">signal</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">audiofile</span><span class="o">.</span><span class="n">read</span><span class="p">(</span>
                <span class="n">outfile</span><span class="p">,</span>
                <span class="n">always_2d</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">normalize_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">NormalizeByPeak</span><span class="p">(</span><span class="n">peak_db</span><span class="o">=</span><span class="n">normalize_db</span><span class="p">)(</span><span class="n">signal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">makeup_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">from_db</span><span class="p">(</span><span class="n">makeup_db</span><span class="p">)</span> <span class="o">*</span> <span class="n">signal</span>

        <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">Clip</span><span class="p">()(</span><span class="n">signal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="Fade"><a class="viewcode-back" href="../../../api/auglib.transform.Fade.html#auglib.transform.Fade">[docs]</a><span class="k">class</span> <span class="nc">Fade</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fade-in and fade-out of signal.</span>

<span class="sd">    A fade is a gradual increase (fade-in)</span>
<span class="sd">    or decrease (fade-out)</span>
<span class="sd">    in the level</span>
<span class="sd">    of an audio signal.</span>
<span class="sd">    If ``in_db`` is greater than -120 dB</span>
<span class="sd">    the fade-in will start from the corresponding level,</span>
<span class="sd">    otherwise from silence.</span>
<span class="sd">    If ``out_db`` is greater than -120 dB</span>
<span class="sd">    the fade-out will end at the corresponding level,</span>
<span class="sd">    otherwise from silence.</span>

<span class="sd">    The shape of the fade-in and fade-out</span>
<span class="sd">    is selected via ``in_shape`` and ``out_shape``.</span>
<span class="sd">    The following figure shows all available shapes</span>
<span class="sd">    by the example of a fade-in.</span>

<span class="sd">    .. plot::</span>
<span class="sd">        :include-source: False</span>

<span class="sd">        import auglib</span>
<span class="sd">        import matplotlib.pyplot as plt</span>
<span class="sd">        import matplotlib.ticker as mtick</span>
<span class="sd">        import numpy as np</span>
<span class="sd">        import seaborn as sns</span>

<span class="sd">        plt.rcParams[&#39;font.size&#39;] = 13</span>
<span class="sd">        for shape in auglib.core.transform.SUPPORTED_FADE_SHAPES:</span>
<span class="sd">            transform = auglib.transform.Fade(</span>
<span class="sd">                in_dur=101,</span>
<span class="sd">                in_shape=shape,</span>
<span class="sd">                out_dur=0,</span>
<span class="sd">                unit=&#39;samples&#39;,</span>
<span class="sd">            )</span>
<span class="sd">            augment = auglib.Augment(transform)</span>
<span class="sd">            augmented_signal = augment(np.ones(101), 1000)</span>
<span class="sd">            plt.plot(augmented_signal[0], label=shape)</span>
<span class="sd">        plt.ylabel(&#39;Magnitude&#39;)</span>
<span class="sd">        plt.xlabel(&#39;Fade-in Length&#39;)</span>
<span class="sd">        plt.legend()</span>
<span class="sd">        plt.grid(alpha=0.4)</span>
<span class="sd">        ax = plt.gca()</span>
<span class="sd">        ax.xaxis.set_major_formatter(mtick.PercentFormatter())</span>
<span class="sd">        ax.tick_params(axis=u&#39;both&#39;, which=u&#39;both&#39;,length=0)</span>
<span class="sd">        plt.xlim([-1.2, 100.2])</span>
<span class="sd">        plt.ylim([-0.02, 1])</span>
<span class="sd">        sns.despine(left=True, bottom=True)</span>

<span class="sd">    Args:</span>
<span class="sd">        in_dur: duration of fade-in</span>
<span class="sd">        out_dur: duration of fade-out</span>
<span class="sd">        in_shape: shape of fade-in</span>
<span class="sd">        out_shape: shape of fade-out</span>
<span class="sd">        in_db: level in dB the fade-in should start at,</span>
<span class="sd">            -120 dB or less is equivalent</span>
<span class="sd">            to an amplitude of 0</span>
<span class="sd">        out_db: level in dB the fade-out should end at,</span>
<span class="sd">            -120 dB or less is equivalent</span>
<span class="sd">            to an amplitude of 0</span>
<span class="sd">        unit: literal specifying the format of ``duration``</span>
<span class="sd">            (see :meth:`auglib.utils.to_samples`).</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if ``in_shape`` or ``out_shape``</span>
<span class="sd">            contains a non-supported value</span>
<span class="sd">        ValueError: if ``in_db`` or ``out_db``</span>
<span class="sd">            are greater or equal to 0</span>

<span class="sd">    Examples:</span>
<span class="sd">        Fade in a speech signal by 0.2 s,</span>
<span class="sd">        and fade out by 0.7 s.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Fade(in_dur=0.2, out_dur=0.7)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-fade0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-fade0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Inspect fade window.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; signal = np.ones(signal.shape)</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_dur</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">out_dur</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">in_shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;tukey&quot;</span><span class="p">,</span>
        <span class="n">out_shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;tukey&quot;</span><span class="p">,</span>
        <span class="n">in_db</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span>
        <span class="n">out_db</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">120</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="p">[</span><span class="n">in_shape</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_FADE_SHAPES</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unknown fade shape &#39;</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                    <span class="s2">&quot;Supported designs are: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SUPPORTED_FADE_SHAPES</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="p">[</span><span class="n">in_db</span><span class="p">,</span> <span class="n">out_db</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Fading level needs to be below 0 dB, &quot;</span> <span class="sa">f</span><span class="s2">&quot;not </span><span class="si">{</span><span class="n">level</span><span class="si">}</span><span class="s2"> dB.&quot;</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_dur</span> <span class="o">=</span> <span class="n">in_dur</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_dur</span> <span class="o">=</span> <span class="n">out_dur</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_shape</span> <span class="o">=</span> <span class="n">in_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_shape</span> <span class="o">=</span> <span class="n">out_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_db</span> <span class="o">=</span> <span class="n">in_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_db</span> <span class="o">=</span> <span class="n">out_db</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">in_shape</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_shape</span><span class="p">)</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_shape</span><span class="p">)</span>
        <span class="n">in_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_db</span><span class="p">)</span>
        <span class="n">out_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_db</span><span class="p">)</span>
        <span class="n">in_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
            <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_dur</span><span class="p">),</span>
            <span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">out_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
            <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_dur</span><span class="p">),</span>
            <span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">fade_in</span> <span class="o">=</span> <span class="n">audmath</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="n">in_samples</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">in_shape</span><span class="p">,</span> <span class="n">half</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="n">fade_out</span> <span class="o">=</span> <span class="n">audmath</span><span class="o">.</span><span class="n">window</span><span class="p">(</span><span class="n">out_samples</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">out_shape</span><span class="p">,</span> <span class="n">half</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>

        <span class="c1"># Adjust start level of fade-in</span>
        <span class="c1"># and/or end level of fade-out</span>
        <span class="c1"># if requested</span>
        <span class="k">if</span> <span class="n">in_db</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">120</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">from_db</span><span class="p">(</span><span class="n">in_db</span><span class="p">)</span>
            <span class="n">fade_in</span> <span class="o">=</span> <span class="n">fade_in</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">if</span> <span class="n">out_db</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">120</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">from_db</span><span class="p">(</span><span class="n">out_db</span><span class="p">)</span>
            <span class="n">fade_out</span> <span class="o">=</span> <span class="n">fade_out</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="n">fade_in_win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">fade_in</span><span class="p">[:</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                    <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">in_samples</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">DTYPE</span><span class="p">)</span>
        <span class="n">fade_out_win</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                    <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">out_samples</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">fade_out</span><span class="p">[</span><span class="o">-</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">:],</span>
            <span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">DTYPE</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">fade_in_win</span> <span class="o">*</span> <span class="n">fade_out_win</span> <span class="o">*</span> <span class="n">signal</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="FFTConvolve"><a class="viewcode-back" href="../../../api/auglib.transform.FFTConvolve.html#auglib.transform.FFTConvolve">[docs]</a><span class="k">class</span> <span class="nc">FFTConvolve</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convolve signal with another signal.</span>

<span class="sd">    The convolution is done by a FFT-based approach.</span>

<span class="sd">    Args:</span>
<span class="sd">        aux: auxiliary signal,</span>
<span class="sd">            file,</span>
<span class="sd">            or signal generating transform.</span>
<span class="sd">            If a transform is given</span>
<span class="sd">            it will be applied</span>
<span class="sd">            to an empty signal with the same length</span>
<span class="sd">            as the base signal</span>
<span class="sd">        keep_tail: keep the tail of the convolution result</span>
<span class="sd">            (extending the length of the signal),</span>
<span class="sd">            or to cut it out</span>
<span class="sd">            (keeping the original length of the input)</span>
<span class="sd">        transform: transformation applied to the auxiliary signal</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Filter a speech signal by a `Telefunken M201/1`_ microphone.</span>

<span class="sd">        .. _Telefunken M201/1: https://micirp.blogspot.com/2013/11/telefunken-m2011.html</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(</span>
<span class="sd">            ...     &quot;micirp&quot;,</span>
<span class="sd">            ...     &quot;dirs/Telefunken_M201.wav&quot;,</span>
<span class="sd">            ...     version=&quot;1.0.0&quot;,</span>
<span class="sd">            ...     sampling_rate=16000,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.FFTConvolve(files[0])</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-fft-convolve0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-fft-convolve0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Inspect its magnitude spectrum.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audmath</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; sigs = [signal, augmented_signal]</span>
<span class="sd">            &gt;&gt;&gt; colors = [&quot;#5d6370&quot;, &quot;#e13b41&quot;]</span>
<span class="sd">            &gt;&gt;&gt; for sig, color in zip(sigs, colors):</span>
<span class="sd">            ...     magnitude, f = plt.mlab.magnitude_spectrum(sig, Fs=sampling_rate)</span>
<span class="sd">            ...     # Smooth magnitude</span>
<span class="sd">            ...     magnitude = np.convolve(magnitude, np.ones(14) / 14, mode=&quot;same&quot;)</span>
<span class="sd">            ...     plt.plot(f, audmath.db(magnitude), color=color)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlim([10, 8000])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylim([-100, -45])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylabel(&quot;Magnitude / dB&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlabel(&quot;Frequency / Hz&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.legend([&quot;signal&quot;, &quot;augmented signal&quot;])</span>
<span class="sd">            &gt;&gt;&gt; plt.grid(alpha=0.4)</span>
<span class="sd">            &gt;&gt;&gt; sns.despine()</span>
<span class="sd">            &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">keep_tail</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Base</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">aux</span><span class="o">=</span><span class="n">aux</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_tail</span> <span class="o">=</span> <span class="n">keep_tail</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">keep_tail</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keep_tail</span><span class="p">)</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">fftconvolve</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_tail</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[:,</span> <span class="p">:</span><span class="n">samples</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="Function"><a class="viewcode-back" href="../../../api/auglib.transform.Function.html#auglib.transform.Function">[docs]</a><span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a custom function to the signal.</span>

<span class="sd">    The function gets as input a :class:`numpy.ndarray`</span>
<span class="sd">    of shape ``(channels, samples)``</span>
<span class="sd">    with the content of the audio signal</span>
<span class="sd">    and the sampling rate.</span>
<span class="sd">    Additional arguments can be provided with</span>
<span class="sd">    the ``function_args`` dictionary.</span>
<span class="sd">    Observable arguments</span>
<span class="sd">    (e.g. :class:`auglib.IntUni`)</span>
<span class="sd">    are automatically evaluated.</span>
<span class="sd">    The function must return a :class:`numpy.ndarray`.</span>

<span class="sd">    Note that the object is not serializable</span>
<span class="sd">    if the function relies on other locally defined functions.</span>
<span class="sd">    For instance,</span>
<span class="sd">    in this example object ``f`` is not serializable:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        def _plus_1(x, sr):</span>
<span class="sd">            return x + 1</span>


<span class="sd">        def plus_1(x, sr):</span>
<span class="sd">            return _plus_1(x, sr)  # calls local function -&gt; not serializable</span>


<span class="sd">        f = auglib.transform.Function(plus_1)</span>


<span class="sd">    Args:</span>
<span class="sd">        function: (lambda) function object</span>
<span class="sd">        function_args: dictionary with additional function arguments</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Define a shutter function</span>
<span class="sd">        and set every second sample to 0</span>
<span class="sd">        in a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; def shutter(signal, sampling_rate, block=1, non_block=1):</span>
<span class="sd">            ...     n = 0</span>
<span class="sd">            ...     augmented_signal = signal.copy()</span>
<span class="sd">            ...     while n &lt; augmented_signal.shape[1]:</span>
<span class="sd">            ...         augmented_signal[:, n + non_block : n + non_block + block] = 0</span>
<span class="sd">            ...         n += block + non_block</span>
<span class="sd">            ...     return augmented_signal</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Function(shutter)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-function0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-function0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Repeatedly set 400 samples to zero,</span>
<span class="sd">        and leave 800 samples untouched of a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Function(shutter, {&quot;block&quot;: 400, &quot;non_block&quot;: 800})</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-function1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-function1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="nd">@audobject</span><span class="o">.</span><span class="n">init_decorator</span><span class="p">(</span>
        <span class="n">resolvers</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">audobject</span><span class="o">.</span><span class="n">resolver</span><span class="o">.</span><span class="n">Function</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">function_args</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_args</span> <span class="o">=</span> <span class="n">function_args</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># evaluate function arguments</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_args</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="GainStage"><a class="viewcode-back" href="../../../api/auglib.transform.GainStage.html#auglib.transform.GainStage">[docs]</a><span class="k">class</span> <span class="nc">GainStage</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Scale signal by linear factor.</span>

<span class="sd">    If ``max_peak_db`` is not ``None``,</span>
<span class="sd">    the gain will be adjusted</span>
<span class="sd">    to never exceed the maximum.</span>

<span class="sd">    If ``clip`` is ``True``</span>
<span class="sd">    the resulting peak never exceeds 0 dB,</span>
<span class="sd">    even when ``max_peak_db`` &gt; 0dB.</span>

<span class="sd">    Args:</span>
<span class="sd">        gain_db: amplification in decibels</span>
<span class="sd">        max_peak_db: maximum peak level allowed in decibels (see note)</span>
<span class="sd">        clip: clip sample values to the interval [-1.0, 1.0]</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Half the amplitude values</span>
<span class="sd">        of a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; gain = auglib.utils.to_db(0.5)</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.GainStage(gain)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-gain-stage0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-gain-stage0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">gain_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">max_peak_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">clip</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span> <span class="o">=</span> <span class="n">gain_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_peak_db</span> <span class="o">=</span> <span class="n">max_peak_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip</span> <span class="o">=</span> <span class="n">clip</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">gain_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span><span class="p">)</span>
        <span class="n">clip</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clip</span><span class="p">)</span>
        <span class="n">max_peak_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_peak_db</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_peak_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">current_peak_db</span> <span class="o">=</span> <span class="n">to_db</span><span class="p">(</span><span class="n">get_peak</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
            <span class="n">new_peak_db</span> <span class="o">=</span> <span class="n">gain_db</span> <span class="o">+</span> <span class="n">current_peak_db</span>
            <span class="k">if</span> <span class="n">new_peak_db</span> <span class="o">&gt;</span> <span class="n">max_peak_db</span><span class="p">:</span>
                <span class="n">gain_db</span> <span class="o">=</span> <span class="n">max_peak_db</span> <span class="o">-</span> <span class="n">current_peak_db</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">GainStage</span><span class="p">(</span><span class="n">gain_db</span><span class="p">)(</span><span class="n">signal</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">gain</span> <span class="o">=</span> <span class="n">from_db</span><span class="p">(</span><span class="n">gain_db</span><span class="p">)</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">signal</span>

        <span class="k">if</span> <span class="n">clip</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">Clip</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">)(</span><span class="n">signal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="HighPass"><a class="viewcode-back" href="../../../api/auglib.transform.HighPass.html#auglib.transform.HighPass">[docs]</a><span class="k">class</span> <span class="nc">HighPass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Run audio signal through a high-pass filter.</span>

<span class="sd">    Args:</span>
<span class="sd">        cutoff: cutoff frequency in Hz</span>
<span class="sd">        order: filter order</span>
<span class="sd">        design: filter design,</span>
<span class="sd">            at the moment only ``&#39;butter&#39;`` is available</span>
<span class="sd">            corresponding to a Butterworth filter</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if ``design`` contains a non-supported value</span>

<span class="sd">    Examples:</span>
<span class="sd">        Filter a speech signal</span>
<span class="sd">        with a 4000 Hz,</span>
<span class="sd">        4th order high pass.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.HighPass(4000, order=4)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-high-pass0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-high-pass0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Inspect its magnitude spectrum.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audmath</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; sigs = [signal, augmented_signal]</span>
<span class="sd">            &gt;&gt;&gt; colors = [&quot;#5d6370&quot;, &quot;#e13b41&quot;]</span>
<span class="sd">            &gt;&gt;&gt; for sig, color in zip(sigs, colors):</span>
<span class="sd">            ...     magnitude, f = plt.mlab.magnitude_spectrum(sig, Fs=sampling_rate)</span>
<span class="sd">            ...     # Smooth magnitude</span>
<span class="sd">            ...     magnitude = np.convolve(magnitude, np.ones(14) / 14, mode=&quot;same&quot;)</span>
<span class="sd">            ...     plt.plot(f, audmath.db(magnitude), color=color)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlim([10, 8000])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylim([-100, -45])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylabel(&quot;Magnitude / dB&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlabel(&quot;Frequency / Hz&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.legend([&quot;signal&quot;, &quot;augmented signal&quot;])</span>
<span class="sd">            &gt;&gt;&gt; plt.grid(alpha=0.4)</span>
<span class="sd">            &gt;&gt;&gt; sns.despine()</span>
<span class="sd">            &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">        The high pass can also filter signals</span>
<span class="sd">        added by other transforms.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Mix(</span>
<span class="sd">            ...     auglib.transform.WhiteNoiseGaussian(),</span>
<span class="sd">            ...     snr_db=10,</span>
<span class="sd">            ...     transform=auglib.transform.HighPass(7000, order=4),</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-high-pass1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-high-pass1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">design</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;butter&quot;</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">if</span> <span class="n">design</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_FILTER_DESIGNS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown filter design &#39;</span><span class="si">{</span><span class="n">design</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="s2">&quot;Supported designs are: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SUPPORTED_FILTER_DESIGNS</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">=</span> <span class="n">design</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sampling_rate is &#39;None&#39;, but required.&quot;</span><span class="p">)</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;butter&quot;</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span>
                <span class="n">order</span><span class="p">,</span>
                <span class="n">cutoff</span><span class="p">,</span>
                <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;highpass&quot;</span><span class="p">,</span>
                <span class="n">fs</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">DTYPE</span><span class="p">)</span></div>


<div class="viewcode-block" id="LowPass"><a class="viewcode-back" href="../../../api/auglib.transform.LowPass.html#auglib.transform.LowPass">[docs]</a><span class="k">class</span> <span class="nc">LowPass</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Run audio signal through a low-pass filter.</span>

<span class="sd">    Args:</span>
<span class="sd">        cutoff: cutoff frequency in Hz</span>
<span class="sd">        order: filter order</span>
<span class="sd">        design: filter design,</span>
<span class="sd">            at the moment only ``&#39;butter&#39;`` is available</span>
<span class="sd">            corresponding to a Butterworth filter</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if ``design`` contains a non-supported value</span>

<span class="sd">    Examples:</span>
<span class="sd">        Filter a speech signal</span>
<span class="sd">        with a 2000 Hz,</span>
<span class="sd">        2th order low pass.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.LowPass(2000, order=2)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-low-pass0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-low-pass0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Inspect its magnitude spectrum.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audmath</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; sigs = [signal, augmented_signal]</span>
<span class="sd">            &gt;&gt;&gt; colors = [&quot;#5d6370&quot;, &quot;#e13b41&quot;]</span>
<span class="sd">            &gt;&gt;&gt; for sig, color in zip(sigs, colors):</span>
<span class="sd">            ...     magnitude, f = plt.mlab.magnitude_spectrum(sig, Fs=sampling_rate)</span>
<span class="sd">            ...     # Smooth magnitude</span>
<span class="sd">            ...     magnitude = np.convolve(magnitude, np.ones(14) / 14, mode=&quot;same&quot;)</span>
<span class="sd">            ...     plt.plot(f, audmath.db(magnitude), color=color)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlim([10, 8000])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylim([-100, -45])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylabel(&quot;Magnitude / dB&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlabel(&quot;Frequency / Hz&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.legend([&quot;signal&quot;, &quot;augmented signal&quot;])</span>
<span class="sd">            &gt;&gt;&gt; plt.grid(alpha=0.4)</span>
<span class="sd">            &gt;&gt;&gt; sns.despine()</span>
<span class="sd">            &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">        The low pass can also filter signals</span>
<span class="sd">        added by other transforms.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Mix(</span>
<span class="sd">            ...     auglib.transform.WhiteNoiseGaussian(),</span>
<span class="sd">            ...     snr_db=10,</span>
<span class="sd">            ...     transform=auglib.transform.LowPass(2000, order=2),</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-low-pass1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-low-pass1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cutoff</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">design</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;butter&quot;</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">if</span> <span class="n">design</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_FILTER_DESIGNS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown filter design &#39;</span><span class="si">{</span><span class="n">design</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="s2">&quot;Supported designs are: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SUPPORTED_FILTER_DESIGNS</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">=</span> <span class="n">design</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sampling_rate is &#39;None&#39;, but required.&quot;</span><span class="p">)</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">design</span> <span class="o">==</span> <span class="s2">&quot;butter&quot;</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span>
                <span class="n">order</span><span class="p">,</span>
                <span class="n">cutoff</span><span class="p">,</span>
                <span class="n">btype</span><span class="o">=</span><span class="s2">&quot;lowpass&quot;</span><span class="p">,</span>
                <span class="n">fs</span><span class="o">=</span><span class="n">sampling_rate</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">lfilter</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">signal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">DTYPE</span><span class="p">)</span></div>


<div class="viewcode-block" id="Mask"><a class="viewcode-back" href="../../../api/auglib.transform.Mask.html#auglib.transform.Mask">[docs]</a><span class="k">class</span> <span class="nc">Mask</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Masked transformation.</span>

<span class="sd">    Usually a transformation is applied on the whole signal.</span>
<span class="sd">    With :class:`auglib.transform.Mask` it is possible</span>
<span class="sd">    to mask the transformation within specific region(s).</span>
<span class="sd">    By default,</span>
<span class="sd">    regions outside the mask are augmented.</span>
<span class="sd">    If ``invert`` is set to ``True``,</span>
<span class="sd">    regions that fall inside the mask are augmented.</span>

<span class="sd">    Args:</span>
<span class="sd">        transform: transform object</span>
<span class="sd">        start_pos: start masking at this point (see ``unit``).</span>
<span class="sd">        duration: apply masking for this duration (see ``unit``).</span>
<span class="sd">            If set to ``None``</span>
<span class="sd">            masking is applied until the end of the signal</span>
<span class="sd">        step: if not ``None``,</span>
<span class="sd">            alternate between masked and non-masked regions</span>
<span class="sd">            by the given step duration.</span>
<span class="sd">            If two steps are given,</span>
<span class="sd">            the first value defines the length of masked regions,</span>
<span class="sd">            and the second value the steps between masked regions</span>
<span class="sd">            (see ``unit``)</span>
<span class="sd">        invert: if set to ``True`` augment the masked regions</span>
<span class="sd">        unit: literal specifying the format of ``step``,</span>
<span class="sd">            ``start_pos`` and ``duration``</span>
<span class="sd">            (see :meth:`auglib.utils.to_samples`)</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Reduce the gain of a speech signal by -20 dB,</span>
<span class="sd">        only in the region outside of 0.5 s to 1.0 s.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Mask(</span>
<span class="sd">            ...     auglib.transform.GainStage(-20),</span>
<span class="sd">            ...     start_pos=0.5,</span>
<span class="sd">            ...     duration=0.5,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-mask0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-mask0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Invert the region in which the gain is reduced.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Mask(</span>
<span class="sd">            ...     auglib.transform.GainStage(-20),</span>
<span class="sd">            ...     start_pos=0.5,</span>
<span class="sd">            ...     duration=0.5,</span>
<span class="sd">            ...     invert=True,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-mask1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-mask1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Repeat a mask of length 0.2 s</span>
<span class="sd">        after a pause of 0.3 s.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Mask(</span>
<span class="sd">            ...     auglib.transform.GainStage(-20),</span>
<span class="sd">            ...     step=(0.2, 0.3),</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-mask2.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-mask2.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="nd">@audobject</span><span class="o">.</span><span class="n">init_decorator</span><span class="p">(</span>
        <span class="n">resolvers</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;step&quot;</span><span class="p">:</span> <span class="n">audobject</span><span class="o">.</span><span class="n">resolver</span><span class="o">.</span><span class="n">Tuple</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Base</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">start_pos</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">step</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span>
            <span class="nb">int</span><span class="p">,</span>
            <span class="nb">float</span><span class="p">,</span>
            <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span>
            <span class="n">Time</span><span class="p">,</span>
            <span class="n">typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span>
                <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">],</span>
                <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">],</span>
            <span class="p">],</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">invert</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">audeer</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">step</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">step</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="o">=</span> <span class="n">start_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert</span> <span class="o">=</span> <span class="n">invert</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># store original signal, then apply transformation</span>
        <span class="n">org_signal</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">org_signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># figure start and end position of mask</span>
        <span class="n">start_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_pos</span> <span class="o">=</span> <span class="n">num_samples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_pos</span> <span class="o">=</span> <span class="n">start_pos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">,</span>
                <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">end_pos</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">end_pos</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>

        <span class="c1"># create mask</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_samples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[:,</span> <span class="p">:</span><span class="n">start_pos</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mask</span><span class="p">[:,</span> <span class="n">end_pos</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># apply steps</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">masked_region</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">while</span> <span class="n">start_pos</span> <span class="o">&lt;</span> <span class="n">end_pos</span><span class="p">:</span>
                <span class="c1"># switch between the two frequencies</span>
                <span class="c1"># freq[0] -&gt; mask</span>
                <span class="c1"># freq[1] -&gt; no mask</span>
                <span class="c1"># and calculate next step</span>
                <span class="k">if</span> <span class="n">masked_region</span><span class="p">:</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                    <span class="n">step</span><span class="p">,</span>
                    <span class="n">sampling_rate</span><span class="p">,</span>
                    <span class="n">length</span><span class="o">=</span><span class="n">num_samples</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">step</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">end_pos</span> <span class="o">-</span> <span class="n">start_pos</span><span class="p">)</span>
                <span class="c1"># if we are not in a masked region, revert changes</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">masked_region</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mask</span><span class="p">[:,</span> <span class="n">start_pos</span> <span class="p">:</span> <span class="n">start_pos</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># increment position and switch condition</span>
                <span class="n">start_pos</span> <span class="o">+=</span> <span class="n">step</span>
                <span class="n">masked_region</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">masked_region</span>

        <span class="c1"># apply mask</span>
        <span class="c1"># invert = False -&gt; remove augmentation within mask</span>
        <span class="c1"># invert = True -&gt; keep augmentation within mask</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invert</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">mask</span>
        <span class="n">signal</span><span class="p">[:,</span> <span class="p">:</span><span class="n">num_samples</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">org_signal</span><span class="p">[:,</span> <span class="p">:</span><span class="n">num_samples</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="Mix"><a class="viewcode-back" href="../../../api/auglib.transform.Mix.html#auglib.transform.Mix">[docs]</a><span class="k">class</span> <span class="nc">Mix</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Mix two audio signals.</span>

<span class="sd">    Mix a base signal and auxiliary signal</span>
<span class="sd">    which may differ in length,</span>
<span class="sd">    but must have the same sampling rate.</span>
<span class="sd">    Individual gains can be set for both signals</span>
<span class="sd">    (``gain_base_db`` and ``gain_aux_db``).</span>
<span class="sd">    If ``snr_db`` is specified,</span>
<span class="sd">    ``gain_aux_db`` is automatically calculated</span>
<span class="sd">    to match the requested signal-to-noise ratio.</span>
<span class="sd">    The signal-to-noise ratio</span>
<span class="sd">    refers only to the overlapping parts</span>
<span class="sd">    of the base and auxiliary signal.</span>

<span class="sd">    ``write_pos_base`` specifies the starting point</span>
<span class="sd">    of adding the auxiliary signal</span>
<span class="sd">    to the the base signal.</span>
<span class="sd">    Selecting a sub-segment of the auxiliary signal is possible</span>
<span class="sd">    with selecting a starting point (``read_pos_aux``)</span>
<span class="sd">    and/or specifying its duration (``read_dur_aux``).</span>

<span class="sd">    In order to allow the looping of the auxiliary signal</span>
<span class="sd">    or its selected sub-segment,</span>
<span class="sd">    the ``loop_aux`` argument can be used.</span>
<span class="sd">    In case the auxiliary signal ends beyond</span>
<span class="sd">    the original ending point,</span>
<span class="sd">    the extra portion will be discarded,</span>
<span class="sd">    unless ``extend_base`` is set,</span>
<span class="sd">    in which case the base signal is extended accordingly.</span>

<span class="sd">    By default,</span>
<span class="sd">    the auxiliary signal is mixed</span>
<span class="sd">    into the base signal exactly once.</span>
<span class="sd">    However, the number of repetitions</span>
<span class="sd">    can be controlled with ``num_repeat``.</span>
<span class="sd">    Usually,</span>
<span class="sd">    this only makes sense</span>
<span class="sd">    when reading from random positions</span>
<span class="sd">    or random files.</span>

<span class="sd">    Args:</span>
<span class="sd">        aux: auxiliary signal,</span>
<span class="sd">            file,</span>
<span class="sd">            or signal generating transform.</span>
<span class="sd">            If a transform is given</span>
<span class="sd">            it will be applied</span>
<span class="sd">            to a signal with the same length</span>
<span class="sd">            as the base signal</span>
<span class="sd">            containing zeros</span>
<span class="sd">        gain_base_db: gain of base signal</span>
<span class="sd">        gain_aux_db: gain of auxiliary signal.</span>
<span class="sd">            Ignored if ``snr_db`` is not ``None``</span>
<span class="sd">        snr_db: signal-to-noise (base-to-aux) ratio in decibels</span>
<span class="sd">        write_pos_base: write position of base signal (see ``unit``)</span>
<span class="sd">        read_pos_aux: read position of auxiliary signal (see ``unit``)</span>
<span class="sd">        read_dur_aux: duration to read from auxiliary signal</span>
<span class="sd">            (see ``unit``).</span>
<span class="sd">            Set to ``None`` or ``0`` to read the whole signal</span>
<span class="sd">        clip_mix: clip amplitude values of mixed signal to [-1, 1]</span>
<span class="sd">        loop_aux: loop auxiliary signal if shorter than base signal</span>
<span class="sd">        extend_base: if needed, extend base signal to total required</span>
<span class="sd">            length (considering length of auxiliary signal)</span>
<span class="sd">        num_repeat: number of repetitions</span>
<span class="sd">        sampling_rate: sampling rate in Hz</span>
<span class="sd">        unit: literal specifying the format of ``write_pos_base``,</span>
<span class="sd">            ``read_pos_aux`` and ``read_dur_aux``</span>
<span class="sd">            (see :meth:`auglib.utils.to_samples`)</span>
<span class="sd">        transform: transformation applied to the auxiliary signal</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Select randomly one of 10 noise files</span>
<span class="sd">        and add it with a SNR of 10 dB</span>
<span class="sd">        to a speech signal.</span>
<span class="sd">        If the noise signal shorter</span>
<span class="sd">        than the speech signal,</span>
<span class="sd">        it will be looped.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; auglib.seed(0)</span>
<span class="sd">            &gt;&gt;&gt; db = audb.load(&quot;musan&quot;, media=&quot;.*noise-free-sound-000\d&quot;, version=&quot;1.0.0&quot;)</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Mix(</span>
<span class="sd">            ...     auglib.observe.List(db.files, draw=True),</span>
<span class="sd">            ...     loop_aux=True,</span>
<span class="sd">            ...     snr_db=10,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-mix0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-mix0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Add a cough to a speech signal,</span>
<span class="sd">        starting at a random position between 0% and 90%</span>
<span class="sd">        of the length of the speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; auglib.seed(0)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(</span>
<span class="sd">            ...     &quot;cough-speech-sneeze&quot;,</span>
<span class="sd">            ...     &quot;coughing/kopzxumj430_40.94-41.8.wav&quot;,</span>
<span class="sd">            ...     version=&quot;2.0.1&quot;,</span>
<span class="sd">            ...     sampling_rate=16000,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Mix(</span>
<span class="sd">            ...     files[0],</span>
<span class="sd">            ...     write_pos_base=auglib.observe.FloatUni(0, 0.9),</span>
<span class="sd">            ...     unit=&quot;relative&quot;,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-mix1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-mix1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">gain_base_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">gain_aux_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">snr_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">write_pos_base</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">read_pos_aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">read_dur_aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">clip_mix</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">loop_aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">extend_base</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">num_repeat</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Base</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">aux</span><span class="o">=</span><span class="n">aux</span><span class="p">,</span>
            <span class="n">num_repeat</span><span class="o">=</span><span class="n">num_repeat</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain_base_db</span> <span class="o">=</span> <span class="n">gain_base_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain_aux_db</span> <span class="o">=</span> <span class="n">gain_aux_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span> <span class="o">=</span> <span class="n">snr_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_pos_base</span> <span class="o">=</span> <span class="n">write_pos_base</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pos_aux</span> <span class="o">=</span> <span class="n">read_pos_aux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_dur_aux</span> <span class="o">=</span> <span class="n">read_dur_aux</span> <span class="ow">or</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip_mix</span> <span class="o">=</span> <span class="n">clip_mix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_aux</span> <span class="o">=</span> <span class="n">loop_aux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend_base</span> <span class="o">=</span> <span class="n">extend_base</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">write_pos_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_pos_base</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">read_pos_aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_pos_aux</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">read_dur_aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_dur_aux</span><span class="p">,</span>
            <span class="n">sampling_rate</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">gain_base_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gain_base_db</span><span class="p">)</span>
        <span class="n">clip_mix</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clip_mix</span><span class="p">)</span>
        <span class="n">loop_aux</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loop_aux</span><span class="p">)</span>
        <span class="n">extend_base</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extend_base</span><span class="p">)</span>

        <span class="n">channels</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># only mono supported at the moment</span>

        <span class="n">length_base</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">length_aux</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">clip_mix</span><span class="p">:</span>
            <span class="n">clip</span> <span class="o">=</span> <span class="n">Clip</span><span class="p">()</span>

        <span class="c1"># Apply gain to base signal</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">from_db</span><span class="p">(</span><span class="n">gain_base_db</span><span class="p">)</span> <span class="o">*</span> <span class="n">signal</span>
        <span class="k">if</span> <span class="n">clip_mix</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

        <span class="c1"># If read_dur_aux was `None` or `0`</span>
        <span class="c1"># we set read_dur_aux until the end of the signal</span>
        <span class="n">orig_read_dur_aux</span> <span class="o">=</span> <span class="n">read_dur_aux</span>
        <span class="k">if</span> <span class="n">read_dur_aux</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">read_dur_aux</span> <span class="o">=</span> <span class="n">length_aux</span> <span class="o">-</span> <span class="n">read_pos_aux</span>

        <span class="c1"># Find ending point of mixing for base</span>
        <span class="n">end_pos_base</span> <span class="o">=</span> <span class="n">write_pos_base</span> <span class="o">+</span> <span class="n">read_dur_aux</span>
        <span class="k">if</span> <span class="n">end_pos_base</span> <span class="o">&gt;</span> <span class="n">length_base</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extend_base</span><span class="p">:</span>
                <span class="c1"># Extend base signal by padding with zeros</span>
                <span class="n">zeros</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="n">end_pos_base</span> <span class="o">-</span> <span class="n">length_base</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">signal</span><span class="p">,</span> <span class="n">zeros</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end_pos_base</span> <span class="o">=</span> <span class="n">length_base</span>
        <span class="k">elif</span> <span class="n">loop_aux</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orig_read_dur_aux</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">end_pos_base</span> <span class="o">=</span> <span class="n">length_base</span>  <span class="c1"># allow looping</span>

        <span class="c1"># Adjust aux signal to match required length</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[:,</span> <span class="n">read_pos_aux</span> <span class="p">:</span> <span class="n">read_pos_aux</span> <span class="o">+</span> <span class="n">read_dur_aux</span><span class="p">]</span>
        <span class="n">required_length_aux</span> <span class="o">=</span> <span class="n">end_pos_base</span> <span class="o">-</span> <span class="n">write_pos_base</span>
        <span class="k">if</span> <span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">required_length_aux</span> <span class="ow">and</span> <span class="n">loop_aux</span><span class="p">:</span>
            <span class="n">repetitions</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">required_length_aux</span> <span class="o">/</span> <span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">repetitions</span><span class="p">)</span>

        <span class="c1"># Find end of mixing based on available aux signal</span>
        <span class="k">if</span> <span class="n">required_length_aux</span> <span class="o">&gt;</span> <span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">end_pos</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_pos</span> <span class="o">=</span> <span class="n">required_length_aux</span>

        <span class="c1"># Estimate gain for aux signal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Estimate gain for aux signal</span>
            <span class="c1"># considering only overlapping parts of the signals</span>
            <span class="n">snr_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span><span class="p">)</span>

            <span class="c1"># Ignore zero padded signal parts</span>
            <span class="n">rms_start_base</span> <span class="o">=</span> <span class="n">write_pos_base</span>
            <span class="n">rms_end_base</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">length_base</span><span class="p">,</span> <span class="n">end_pos</span> <span class="o">+</span> <span class="n">write_pos_base</span><span class="p">])</span>
            <span class="n">rms_start_aux</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">rms_end_aux</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">length_base</span> <span class="o">-</span> <span class="n">write_pos_base</span><span class="p">,</span> <span class="n">end_pos</span><span class="p">])</span>

            <span class="n">base_db</span> <span class="o">=</span> <span class="n">rms_db</span><span class="p">(</span><span class="n">signal</span><span class="p">[:,</span> <span class="n">rms_start_base</span><span class="p">:</span><span class="n">rms_end_base</span><span class="p">])</span>
            <span class="n">aux_db</span> <span class="o">=</span> <span class="n">rms_db</span><span class="p">(</span><span class="n">aux</span><span class="p">[:,</span> <span class="n">rms_start_aux</span><span class="p">:</span><span class="n">rms_end_aux</span><span class="p">])</span>
            <span class="n">gain_aux_db</span> <span class="o">=</span> <span class="n">get_noise_gain_from_snr</span><span class="p">(</span><span class="n">base_db</span><span class="p">,</span> <span class="n">aux_db</span><span class="p">,</span> <span class="n">snr_db</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gain_aux_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gain_aux_db</span><span class="p">)</span>

        <span class="n">signal</span><span class="p">[:,</span> <span class="n">write_pos_base</span> <span class="p">:</span> <span class="n">write_pos_base</span> <span class="o">+</span> <span class="n">end_pos</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">from_db</span><span class="p">(</span><span class="n">gain_aux_db</span><span class="p">)</span> <span class="o">*</span> <span class="n">aux</span><span class="p">[:,</span> <span class="p">:</span><span class="n">end_pos</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">clip_mix</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="NormalizeByPeak"><a class="viewcode-back" href="../../../api/auglib.transform.NormalizeByPeak.html#auglib.transform.NormalizeByPeak">[docs]</a><span class="k">class</span> <span class="nc">NormalizeByPeak</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Peak-normalize the signal to a desired level.</span>

<span class="sd">    Args:</span>
<span class="sd">        peak_db: desired peak value in decibels</span>
<span class="sd">        clip: clip sample values to the interval [-1.0, 1.0]</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Normalize the peak value of a speech signal</span>
<span class="sd">        to -10 dB.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.NormalizeByPeak(peak_db=-10)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-normalize-by-peak0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-normalize-by-peak0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">peak_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">clip</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_db</span> <span class="o">=</span> <span class="n">peak_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clip</span> <span class="o">=</span> <span class="n">clip</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">peak_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_db</span><span class="p">)</span>
        <span class="n">clip</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clip</span><span class="p">)</span>
        <span class="n">current_peak</span> <span class="o">=</span> <span class="n">get_peak</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">current_peak</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">signal</span>

        <span class="n">gain_db</span> <span class="o">=</span> <span class="n">peak_db</span> <span class="o">-</span> <span class="n">to_db</span><span class="p">(</span><span class="n">current_peak</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">GainStage</span><span class="p">(</span><span class="n">gain_db</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="n">clip</span><span class="p">)(</span><span class="n">signal</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="PinkNoise"><a class="viewcode-back" href="../../../api/auglib.transform.PinkNoise.html#auglib.transform.PinkNoise">[docs]</a><span class="k">class</span> <span class="nc">PinkNoise</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Adds pink noise.</span>

<span class="sd">    Pink noise or 1/f noise</span>
<span class="sd">    is a signal with a frequency spectrum</span>
<span class="sd">    such that the power spectral density</span>
<span class="sd">    is inversely proportional to the frequency of the signal.</span>
<span class="sd">    It&#39;s magnitude in dB falls 10 dB each octave.</span>

<span class="sd">    Args:</span>
<span class="sd">        gain_db: gain in decibels</span>
<span class="sd">            Ignored if ``snr_db`` is not ``None``</span>
<span class="sd">        snr_db: signal-to-noise ratio in decibels</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Pure pink noise.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; auglib.seed(0)</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.PinkNoise(gain_db=-10)</span>
<span class="sd">            &gt;&gt;&gt; signal = np.zeros((1, 16000))</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-pink-noise0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-pink-noise0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        It&#39;s magnitude falls 10 dB each octave.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audmath</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; magnitude, f = plt.mlab.magnitude_spectrum(augmented_signal[0, :], Fs=16000)</span>
<span class="sd">            &gt;&gt;&gt; # Smooth magnitude</span>
<span class="sd">            &gt;&gt;&gt; magnitude = np.convolve(magnitude, np.ones(14) / 14, mode=&quot;same&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.semilogx(f, audmath.db(magnitude), color=&quot;#e13b41&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlim([10, 10010])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylim([-75, -45])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylabel(&quot;Magnitude / dB&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlabel(&quot;Frequency / Hz&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.grid(alpha=0.4)</span>
<span class="sd">            &gt;&gt;&gt; sns.despine()</span>
<span class="sd">            &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">        Pink Noise added with an SNR of 10 dB to speech.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.PinkNoise(snr_db=10)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-pink-noise1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-pink-noise1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">gain_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">snr_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span> <span class="o">=</span> <span class="n">gain_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span> <span class="o">=</span> <span class="n">snr_db</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pink_noise</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">NormalizeByPeak</span><span class="p">()(</span><span class="n">noise</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">snr_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span><span class="p">)</span>
            <span class="c1"># The RMS value of pink noise signals</span>
            <span class="c1"># generated with a fixed gain</span>
            <span class="c1"># has a larger fluctuation</span>
            <span class="c1"># than for white noise (&gt; 1dB).</span>
            <span class="c1"># To provide a better result</span>
            <span class="c1"># for the requested SNR value</span>
            <span class="c1"># we measure explicitly the actual RMS</span>
            <span class="c1"># of the generated pink noise vector</span>
            <span class="c1"># and adjust the gain afterwards.</span>
            <span class="n">noise_db</span> <span class="o">=</span> <span class="n">rms_db</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
            <span class="n">signal_db</span> <span class="o">=</span> <span class="n">rms_db</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="n">gain_db</span> <span class="o">=</span> <span class="n">get_noise_gain_from_snr</span><span class="p">(</span><span class="n">signal_db</span><span class="p">,</span> <span class="n">noise_db</span><span class="p">,</span> <span class="n">snr_db</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gain_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span><span class="p">)</span>

        <span class="n">base</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">from_db</span><span class="p">(</span><span class="n">gain_db</span><span class="p">)</span> <span class="o">*</span> <span class="n">noise</span>

        <span class="k">return</span> <span class="n">base</span>

    <span class="k">def</span> <span class="nf">_pink_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate pink noise signal.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">psd</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>

        <span class="c1"># Add extra sample</span>
        <span class="c1"># to ensure correct length for odd samples</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">white_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">length</span><span class="p">))</span>

        <span class="c1"># Normalized pink noise shape</span>
        <span class="n">pink_shape</span> <span class="o">=</span> <span class="n">psd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">length</span><span class="p">))</span>
        <span class="n">pink_shape</span> <span class="o">=</span> <span class="n">pink_shape</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pink_shape</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="n">white_noise_shaped</span> <span class="o">=</span> <span class="n">white_noise</span> <span class="o">*</span> <span class="n">pink_shape</span>
        <span class="n">pink_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">white_noise_shaped</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">pink_noise</span><span class="p">[:</span><span class="n">samples</span><span class="p">])</span></div>


<div class="viewcode-block" id="Prepend"><a class="viewcode-back" href="../../../api/auglib.transform.Prepend.html#auglib.transform.Prepend">[docs]</a><span class="k">class</span> <span class="nc">Prepend</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Prepend an auxiliary signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        aux: auxiliary signal,</span>
<span class="sd">            file,</span>
<span class="sd">            or signal generating transform.</span>
<span class="sd">            If a transform is given</span>
<span class="sd">            it will be applied</span>
<span class="sd">            to an empty signal with the same length</span>
<span class="sd">            as the signal</span>
<span class="sd">            the transform is applied to</span>
<span class="sd">        read_pos_aux: read position of auxiliary signal</span>
<span class="sd">            (see ``unit``)</span>
<span class="sd">        read_dur_aux: duration to read from auxiliary signal</span>
<span class="sd">            (see ``unit``).</span>
<span class="sd">            Set to ``None`` or ``0`` to read the whole signal</span>
<span class="sd">        unit: literal specifying the format</span>
<span class="sd">            of ``read_pos_aux`` and ``read_dur_aux``</span>
<span class="sd">            (see :meth:`auglib.utils.to_samples`)</span>
<span class="sd">        transform: transformation applied to the auxiliary signal</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Prepend coughing at the start of a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(</span>
<span class="sd">            ...     &quot;cough-speech-sneeze&quot;,</span>
<span class="sd">            ...     &quot;coughing/kopzxumj430_40.94-41.8.wav&quot;,</span>
<span class="sd">            ...     version=&quot;2.0.1&quot;,</span>
<span class="sd">            ...     sampling_rate=16000,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; cough, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Prepend(cough)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-prepend0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-prepend0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">read_pos_aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">read_dur_aux</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span>
        <span class="n">transform</span><span class="p">:</span> <span class="n">Base</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">aux</span><span class="o">=</span><span class="n">aux</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_pos_aux</span> <span class="o">=</span> <span class="n">read_pos_aux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_dur_aux</span> <span class="o">=</span> <span class="n">read_dur_aux</span> <span class="ow">or</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">aux</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_pos_aux</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">read_pos_aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_pos_aux</span><span class="p">,</span>
                <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">read_pos_aux</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_dur_aux</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">read_dur_aux</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">read_pos_aux</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">read_dur_aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">read_dur_aux</span><span class="p">,</span>
                <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">aux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">aux</span><span class="p">[:,</span> <span class="n">read_pos_aux</span> <span class="p">:</span> <span class="n">read_pos_aux</span> <span class="o">+</span> <span class="n">read_dur_aux</span><span class="p">],</span> <span class="n">signal</span><span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="PrependValue"><a class="viewcode-back" href="../../../api/auglib.transform.PrependValue.html#auglib.transform.PrependValue">[docs]</a><span class="k">class</span> <span class="nc">PrependValue</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Prepend signal with a constant value.</span>

<span class="sd">    Args:</span>
<span class="sd">        duration: duration of signal with constant value</span>
<span class="sd">            that will be prepended</span>
<span class="sd">            (see ``unit``)</span>
<span class="sd">        value: value to prepend</span>
<span class="sd">        unit: literal specifying the format of ``duration``</span>
<span class="sd">            (see :meth:`auglib.utils.to_samples`)</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Prepend zeros at the start of a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.PrependValue(8000, value=0, unit=&quot;samples&quot;)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-prepend-value0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-prepend-value0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">],</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">duration</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                <span class="n">duration</span><span class="p">,</span>
                <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">Prepend</span><span class="p">(</span><span class="n">aux</span><span class="p">)(</span><span class="n">signal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="Resample"><a class="viewcode-back" href="../../../api/auglib.transform.Resample.html#auglib.transform.Resample">[docs]</a><span class="k">class</span> <span class="nc">Resample</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Resample signal to another sampling rate.</span>

<span class="sd">    Changes number of samples of the audio signal</span>
<span class="sd">    by applying :func:`audresample.resample` to the signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        target_rate: target rate in Hz</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        When applying a transform on a file with :class:`auglib.Augment`,</span>
<span class="sd">        it will not change its sampling rate,</span>
<span class="sd">        but its number of samples.</span>
<span class="sd">        Hence,</span>
<span class="sd">        we assume here as well</span>
<span class="sd">        that the sampling rate</span>
<span class="sd">        of the augmented signal</span>
<span class="sd">        stays at 16000 Hz.</span>

<span class="sd">        Resample a speech signal to 8000 Hz,</span>
<span class="sd">        to speed up the signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Resample(8000)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-resample0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-resample0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Inspect its magnitude spectrum.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audmath</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; sigs = [signal, augmented_signal]</span>
<span class="sd">            &gt;&gt;&gt; colors = [&quot;#5d6370&quot;, &quot;#e13b41&quot;]</span>
<span class="sd">            &gt;&gt;&gt; for sig, color in zip(sigs, colors):</span>
<span class="sd">            ...     magnitude, f = plt.mlab.magnitude_spectrum(sig, Fs=sampling_rate)</span>
<span class="sd">            ...     # Smooth magnitude</span>
<span class="sd">            ...     magnitude = np.convolve(magnitude, np.ones(14) / 14, mode=&quot;same&quot;)</span>
<span class="sd">            ...     plt.plot(f, audmath.db(magnitude), color=color)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlim([10, 8000])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylim([-100, -45])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylabel(&quot;Magnitude / dB&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlabel(&quot;Frequency / Hz&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.legend([&quot;signal&quot;, &quot;augmented signal&quot;])</span>
<span class="sd">            &gt;&gt;&gt; plt.grid(alpha=0.4)</span>
<span class="sd">            &gt;&gt;&gt; sns.despine()</span>
<span class="sd">            &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">        Removing the upper half of the signal</span>
<span class="sd">        by frst resampling it to 8000 Hz,</span>
<span class="sd">        and then to 32000 Hz.</span>
<span class="sd">        Again,</span>
<span class="sd">        we listen to the augmented signal</span>
<span class="sd">        at its original sampling rate</span>
<span class="sd">        of 16000 Hz.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Compose(</span>
<span class="sd">            ...     [</span>
<span class="sd">            ...         auglib.transform.Resample(8000),</span>
<span class="sd">            ...         auglib.transform.Resample(32000),</span>
<span class="sd">            ...     ],</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-resample1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-resample1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Inspect its magnitude spectrum.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; sigs = [signal, augmented_signal]</span>
<span class="sd">            &gt;&gt;&gt; for sig, color in zip(sigs, colors):</span>
<span class="sd">            ...     magnitude, f = plt.mlab.magnitude_spectrum(sig, Fs=sampling_rate)</span>
<span class="sd">            ...     # Smooth magnitude</span>
<span class="sd">            ...     magnitude = np.convolve(magnitude, np.ones(14) / 14, mode=&quot;same&quot;)</span>
<span class="sd">            ...     plt.plot(f, audmath.db(magnitude), color=color)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlim([10, 8000])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylim([-100, -45])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylabel(&quot;Magnitude / dB&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlabel(&quot;Frequency / Hz&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.legend([&quot;signal&quot;, &quot;augmented signal&quot;])</span>
<span class="sd">            &gt;&gt;&gt; plt.grid(alpha=0.4)</span>
<span class="sd">            &gt;&gt;&gt; sns.despine()</span>
<span class="sd">            &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">target_rate</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">List</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_rate</span> <span class="o">=</span> <span class="n">target_rate</span>
        <span class="k">if</span> <span class="s2">&quot;override&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">override</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;override&quot;</span><span class="p">]</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;&#39;override&#39; argument is ignored &quot;</span>
                <span class="s2">&quot;and will be removed with version 1.2.0.&quot;</span><span class="p">,</span>
                <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sampling_rate is &#39;None&#39;, but required.&quot;</span><span class="p">)</span>
        <span class="n">target_rate</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_rate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sampling_rate</span> <span class="o">!=</span> <span class="n">target_rate</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">audresample</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
                <span class="n">signal</span><span class="p">,</span>
                <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">target_rate</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="Select"><a class="viewcode-back" href="../../../api/auglib.transform.Select.html#auglib.transform.Select">[docs]</a><span class="k">class</span> <span class="nc">Select</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Randomly select from a pool of transforms.</span>

<span class="sd">    Args:</span>
<span class="sd">        transforms: list of transforms to choose from</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Select randomly a transform</span>
<span class="sd">        and apply to a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; auglib.seed(0)</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Select(</span>
<span class="sd">            ...     [</span>
<span class="sd">            ...         auglib.transform.WhiteNoiseGaussian(snr_db=10),</span>
<span class="sd">            ...         auglib.transform.ClipByRatio(0.1),</span>
<span class="sd">            ...     ],</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-select0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-select0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transforms</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">))</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transforms</span><span class="p">[</span><span class="n">idx</span><span class="p">](</span><span class="n">signal</span><span class="p">,</span> <span class="n">sampling_rate</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="Shift"><a class="viewcode-back" href="../../../api/auglib.transform.Shift.html#auglib.transform.Shift">[docs]</a><span class="k">class</span> <span class="nc">Shift</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Shift signal without changing its duration.</span>

<span class="sd">    The signal will be read</span>
<span class="sd">    from the position</span>
<span class="sd">    given by ``duration``,</span>
<span class="sd">    and the skipped samples from the beginng</span>
<span class="sd">    will be added at the end.</span>

<span class="sd">    Args:</span>
<span class="sd">        duration: duration of shift</span>
<span class="sd">        unit: literal specifying the format of ``duration``</span>
<span class="sd">            (see :meth:`auglib.utils.to_samples`)</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Shift a speech signal by 1 s.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Shift(1)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-append-shift0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-append-shift0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">),</span>
                <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="c1"># Allow shift values that are out-of-bound</span>
            <span class="c1"># of the actual signal duration</span>
            <span class="n">start_pos</span> <span class="o">=</span> <span class="n">duration</span> <span class="o">%</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">start_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">signal</span>
            <span class="c1"># Append data</span>
            <span class="c1"># that will be removed at the beginning</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="n">signal</span><span class="p">,</span> <span class="n">signal</span><span class="p">[:,</span> <span class="p">:</span><span class="n">start_pos</span><span class="p">]],</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Remove data from beginning</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[:,</span> <span class="n">start_pos</span><span class="p">:]</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="Tone"><a class="viewcode-back" href="../../../api/auglib.transform.Tone.html#auglib.transform.Tone">[docs]</a><span class="k">class</span> <span class="nc">Tone</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Adds basic waveform.</span>

<span class="sd">    The sine waveform will start at 0,</span>
<span class="sd">    the square and sawtooth waveform at -1,</span>
<span class="sd">    and the triangle waveform at 1.</span>
<span class="sd">    The waveform sawtooth has a rising ramp.</span>

<span class="sd">    Args:</span>
<span class="sd">        freq: fundamental frequency in Hz</span>
<span class="sd">        gain_db: gain in decibels.</span>
<span class="sd">            Ignored if ``snr_db`` is not ``None``</span>
<span class="sd">        snr_db: signal-to-noise ratio in decibels</span>
<span class="sd">        shape: tone shape,</span>
<span class="sd">            one of ``&#39;sine&#39;``,</span>
<span class="sd">            ``&#39;square&#39;``,</span>
<span class="sd">            ``&#39;triangle&#39;``,</span>
<span class="sd">            ``&#39;sawtooth&#39;``</span>
<span class="sd">        lfo_rate: modulation rate of Low Frequency Oscillator</span>
<span class="sd">        lfo_range: modulation range of Low Frequency Oscillator</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Pure tone with 100 Hz.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Tone(100, gain_db=-10)</span>
<span class="sd">            &gt;&gt;&gt; sampling_rate = 16000</span>
<span class="sd">            &gt;&gt;&gt; signal = np.zeros((1, 1600))</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-tone0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-tone0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Add a triangle shaped tone with 4000 Hz</span>
<span class="sd">        to a speech signal</span>
<span class="sd">        with an SNR of 20 dB.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Tone(4000, shape=&quot;triangle&quot;, snr_db=20)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-tone1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-tone1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">gain_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">snr_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;sine&quot;</span><span class="p">,</span>
        <span class="n">lfo_rate</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">lfo_range</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span> <span class="o">=</span> <span class="n">gain_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span> <span class="o">=</span> <span class="n">snr_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lfo_rate</span> <span class="o">=</span> <span class="n">lfo_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lfo_range</span> <span class="o">=</span> <span class="n">lfo_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sampling_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sampling_rate is &#39;None&#39;, but required.&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq</span><span class="p">)</span>
        <span class="n">lfo_rate</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lfo_rate</span><span class="p">)</span>
        <span class="n">lfo_range</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lfo_range</span><span class="p">)</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_TONE_SHAPES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown tone shape &#39;</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="s2">&quot;Supported shapes are: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SUPPORTED_TONE_SHAPES</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">snr_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span><span class="p">)</span>
            <span class="c1"># RMS values of the tone,</span>
            <span class="c1"># see https://en.wikipedia.org/wiki/Root_mean_square</span>
            <span class="c1">#</span>
            <span class="c1"># For short signals and low sampling rates,</span>
            <span class="c1"># rms_tone_db and hence the resulting SNR</span>
            <span class="c1"># can slightly deviate from the theoretical value.</span>
            <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;sine&quot;</span><span class="p">:</span>
                <span class="n">rms</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;square&quot;</span><span class="p">:</span>
                <span class="n">rms</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;triangle&quot;</span><span class="p">:</span>
                <span class="n">rms</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;sawtooth&quot;</span><span class="p">:</span>
                <span class="n">rms</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">tone_db</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">rms</span><span class="p">)</span>
            <span class="n">signal_db</span> <span class="o">=</span> <span class="n">rms_db</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
            <span class="n">gain_db</span> <span class="o">=</span> <span class="n">get_noise_gain_from_snr</span><span class="p">(</span><span class="n">signal_db</span><span class="p">,</span> <span class="n">tone_db</span><span class="p">,</span> <span class="n">snr_db</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gain_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">lfo_rate</span><span class="p">)</span> <span class="ow">or</span> <span class="n">lfo_rate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lfo_range</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># this will result in no modulation</span>
            <span class="n">lfo_rate</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># dummy value to avoid NAN or division by zero</span>

        <span class="n">period</span> <span class="o">=</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="n">freq</span>  <span class="c1"># in samples</span>
        <span class="n">lfo_period</span> <span class="o">=</span> <span class="n">sampling_rate</span> <span class="o">/</span> <span class="n">lfo_rate</span>  <span class="c1"># in samples</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">period</span>  <span class="c1"># in radians per sample</span>
        <span class="n">lfo_omega</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">lfo_period</span>  <span class="c1"># in radians per sample</span>
        <span class="n">lfo_amp</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">lfo_range</span> <span class="o">/</span> <span class="n">sampling_rate</span>  <span class="c1"># half range (rad)</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">)</span>
        <span class="n">gain</span> <span class="o">=</span> <span class="n">from_db</span><span class="p">(</span><span class="n">gain_db</span><span class="p">)</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">omega</span> <span class="o">*</span> <span class="n">time</span> <span class="o">+</span> <span class="p">(</span><span class="n">lfo_amp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">lfo_omega</span> <span class="o">*</span> <span class="n">time</span><span class="p">)</span> <span class="o">/</span> <span class="n">lfo_omega</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;sine&quot;</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">+=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;square&quot;</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">+=</span> <span class="o">-</span><span class="n">gain</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">duty</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;triangle&quot;</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">+=</span> <span class="o">-</span><span class="n">gain</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">sawtooth</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">shape</span> <span class="o">==</span> <span class="s2">&quot;sawtooth&quot;</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">+=</span> <span class="n">gain</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">sawtooth</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="Trim"><a class="viewcode-back" href="../../../api/auglib.transform.Trim.html#auglib.transform.Trim">[docs]</a><span class="k">class</span> <span class="nc">Trim</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Trim, zero pad, and/or repeat signal.</span>

<span class="sd">    If ``duration`` is ``None``</span>
<span class="sd">    the signal will be trimmed</span>
<span class="sd">    to the range [``start_pos``, ``end_pos``],</span>
<span class="sd">    whereas the start or end of the signal is used</span>
<span class="sd">    if ``start_pos`` and/or ``end_pos`` are ``None``.</span>

<span class="sd">    If ``duration`` is provided</span>
<span class="sd">    and ``fill`` is ``&#39;none&#39;``</span>
<span class="sd">    it will calculate ``start_pos`` or ``end_pos``</span>
<span class="sd">    to match the given duration</span>
<span class="sd">    if the incoming signal is long enough.</span>
<span class="sd">    If ``duration`` is provided,</span>
<span class="sd">    but neither ``start_pos`` or ``end_pos``</span>
<span class="sd">    it will trim a signal with given ``duration``</span>
<span class="sd">    from the center of the signal.</span>

<span class="sd">    If ``duration`` is provided</span>
<span class="sd">    and ``fill`` is ``&#39;zeros&#39;`` or ``&#39;loop&#39;``</span>
<span class="sd">    it will return a signal of length ``duration``</span>
<span class="sd">    filling missing values with zeros</span>
<span class="sd">    or the trimmed signal.</span>
<span class="sd">    ``fill_pos`` defines if the signal is filled</span>
<span class="sd">    on the right, left, or both ends.</span>

<span class="sd">    The following table shows</span>
<span class="sd">    a few combinations of the arguments</span>
<span class="sd">    and the resulting augmented signal</span>
<span class="sd">    for an ingoing signal of ``[1, 2, 3, 4]``.</span>
<span class="sd">    All time values are given in samples.</span>

<span class="sd">    ========= ======= ======== ===== ======== ============</span>
<span class="sd">    start_pos end_pos duration fill  fill_pos outcome</span>
<span class="sd">    ========= ======= ======== ===== ======== ============</span>
<span class="sd">    1         None    None     none  right    [2, 3, 4]</span>
<span class="sd">    None      1       None     none  right    [1, 2, 3]</span>
<span class="sd">    None      None    2        none  right    [2, 3]</span>
<span class="sd">    2         None    4        loop  right    [3, 4, 3, 4]</span>
<span class="sd">    1         1       4        zeros right    [2, 3, 0, 0]</span>
<span class="sd">    3         None    4        zeros both     [0, 4, 0, 0]</span>
<span class="sd">    ========= ======= ======== ===== ======== ============</span>

<span class="sd">    Args:</span>
<span class="sd">        start_pos: starting point of the trimmed region,</span>
<span class="sd">            relative to the start of the input signal</span>
<span class="sd">            (see ``unit``)</span>
<span class="sd">        end_pos: end point of the trimmed region,</span>
<span class="sd">            relative to the end of the input signal</span>
<span class="sd">            (see ``unit``).</span>
<span class="sd">            The end point is counted backwards</span>
<span class="sd">            from the end of the signal.</span>
<span class="sd">            If ``end_pos=512`` samples,</span>
<span class="sd">            it will remove the last 512 samples of the input</span>
<span class="sd">        duration: target duration of the resulting signal</span>
<span class="sd">            (see ``unit``).</span>
<span class="sd">            If set to ``None`` or ``0``,</span>
<span class="sd">            the selected section extends</span>
<span class="sd">            until the end</span>
<span class="sd">            or the beginning</span>
<span class="sd">            of the original signal</span>
<span class="sd">        fill: fill strategy</span>
<span class="sd">            if the end and/or start point</span>
<span class="sd">            of the trimmed region</span>
<span class="sd">            exceeds the signal.</span>
<span class="sd">            Three strategies are available:</span>
<span class="sd">            ``&#39;none&#39;`` the signal is not extended,</span>
<span class="sd">            ``&#39;zeros&#39;`` the signal is filled up with zeros,</span>
<span class="sd">            ``&#39;loop&#39;`` the trimmed signal is repeated</span>
<span class="sd">        fill_pos: position at which the selected fill strategy applies.</span>
<span class="sd">            ``&#39;right&#39;`` adds samples to the right,</span>
<span class="sd">            ``&#39;left&#39;`` adds samples to the left,</span>
<span class="sd">            or ``&#39;both&#39;`` adds samples on both sides,</span>
<span class="sd">            equally distributed starting at the right</span>
<span class="sd">        unit: literal specifying the format</span>
<span class="sd">            of ``start_pos``,</span>
<span class="sd">            ``end_pos``,</span>
<span class="sd">            and ``duration``</span>
<span class="sd">            (see :meth:`auglib.utils.to_samples`)</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: Probability to bypass the transformation</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if ``fill`` contains a non-supported value</span>
<span class="sd">        ValueError: if ``fill_pos`` contains a non-supported value</span>

<span class="sd">    Examples:</span>
<span class="sd">        Remove first 0.2 s and last 0.2 s of a speech signal.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Trim(start_pos=0.2, end_pos=0.2)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, sampling_rate = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-append-trim0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-append-trim0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Trim speech signal to half its current length.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Trim(duration=0.5, unit=&quot;relative&quot;)</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-append-trim1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-append-trim1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        Trim beginning and end of a speech signal,</span>
<span class="sd">        and request a fixed duration.</span>
<span class="sd">        If the trimmed signal is shorter</span>
<span class="sd">        than the requested duration,</span>
<span class="sd">        it is looped.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.Trim(</span>
<span class="sd">            ...     start_pos=0.5,</span>
<span class="sd">            ...     end_pos=0.5,</span>
<span class="sd">            ...     duration=2.0,</span>
<span class="sd">            ...     fill=&quot;loop&quot;,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal, sampling_rate)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-append-trim2.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-append-trim2.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">start_pos</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">end_pos</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">duration</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">,</span> <span class="n">Time</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
        <span class="n">fill_pos</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;seconds&quot;</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">fill</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_FILL_STRATEGIES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown fill strategy &#39;</span><span class="si">{</span><span class="n">fill</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="s2">&quot;Supported strategies are: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SUPPORTED_FILL_STRATEGIES</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">fill_pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">SUPPORTED_FILL_POSITIONS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown fill_pos &#39;</span><span class="si">{</span><span class="n">fill_pos</span><span class="si">}</span><span class="s2">&#39;. &quot;</span>
                <span class="s2">&quot;Supported positions are: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">SUPPORTED_FILL_POSITIONS</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="o">=</span> <span class="n">start_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_pos</span> <span class="o">=</span> <span class="n">end_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_pos</span> <span class="o">=</span> <span class="n">fill_pos</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># start_pos | end_pos | duration</span>
        <span class="c1"># --------- | ------- | --------</span>
        <span class="c1"># None      | None    | None/0</span>
        <span class="c1">#</span>
        <span class="c1"># Return signal without trimming</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_pos</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">signal</span>

        <span class="c1"># Convert start_pos, end_pos, duration to samples</span>
        <span class="c1"># and check for meaningful values</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span><span class="p">),</span>
                <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">start_pos</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;start_pos&#39; must be &lt;</span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start_pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;start_pos&#39; must be &gt;=0.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end_pos</span><span class="p">),</span>
                <span class="n">sampling_rate</span><span class="p">,</span>
                <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">end_pos</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;end_pos&#39; must be &lt;</span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end_pos</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;end_pos&#39; must be &gt;=0.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">duration</span> <span class="o">=</span> <span class="n">length</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_samples</span><span class="p">(</span>
                    <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">duration</span><span class="p">),</span>
                    <span class="n">sampling_rate</span><span class="p">,</span>
                    <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
                    <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">duration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;duration&#39; must be &gt;=0.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">duration</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Your combination of &quot;</span>
                    <span class="s2">&quot;&#39;duration&#39; = 0.0001 seconds &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;and &#39;sampling_rate&#39; = </span><span class="si">{</span><span class="n">sampling_rate</span><span class="si">}</span><span class="s2"> Hz &quot;</span>
                    <span class="s2">&quot;would lead to an empty signal &quot;</span>
                    <span class="s2">&quot;which is forbidden.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># start_pos | end_pos | duration</span>
        <span class="c1"># --------- | ------- | --------</span>
        <span class="c1"># value     | value   |</span>
        <span class="c1">#</span>
        <span class="c1"># If start_pos and end_pos are given</span>
        <span class="c1"># we need to ensure</span>
        <span class="c1"># that they would not result</span>
        <span class="c1"># in an empty array</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">length</span> <span class="o">-</span> <span class="n">start_pos</span> <span class="o">-</span> <span class="n">end_pos</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;start_pos&#39; + &#39;end_pos&#39; must be &lt;</span><span class="si">{</span><span class="n">length</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># start_pos | end_pos | duration</span>
        <span class="c1"># --------- | ------- | --------</span>
        <span class="c1">#           |         | None</span>
        <span class="c1">#</span>
        <span class="c1"># Calculate duration if not given</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">end_pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">start_pos</span> <span class="o">-</span> <span class="n">end_pos</span>

        <span class="c1"># start_pos | end_pos | duration</span>
        <span class="c1"># --------- | ------- | --------</span>
        <span class="c1">#           |         | value</span>
        <span class="c1">#</span>
        <span class="c1"># Return trimmed signal based on duration.</span>
        <span class="c1"># If the duration is longer</span>
        <span class="c1"># than the incoming signal</span>
        <span class="c1"># or the trimmed signal</span>
        <span class="c1"># based on start_pos and/or end_pos,</span>
        <span class="c1"># the signal is also filled</span>
        <span class="c1"># according to fill and fill_pos</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">distribute_samples</span><span class="p">(</span><span class="n">num_samples</span><span class="p">):</span>
<span class="w">                </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Distribute samples to left and right.</span>

<span class="sd">                If ``num_samples`` is zero or negative</span>
<span class="sd">                ``0, 0`` is returned.</span>

<span class="sd">                If ``num_samples`` is even</span>
<span class="sd">                more samples are returned on the right side.</span>

<span class="sd">                &quot;&quot;&quot;</span>
                <span class="k">if</span> <span class="n">num_samples</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_samples</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_samples</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="c1"># For even numbers add one sample to the right</span>
                <span class="k">if</span> <span class="n">num_samples</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">end</span> <span class="o">+=</span> <span class="n">num_samples</span>
                <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span>

            <span class="c1"># First trim to [start_pos, end_pos]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If signal is longer than duration cut from center</span>
                <span class="n">start_pos</span><span class="p">,</span> <span class="n">end_pos</span> <span class="o">=</span> <span class="n">distribute_samples</span><span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="n">duration</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="n">duration</span> <span class="o">-</span> <span class="n">end_pos</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">end_pos</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="n">duration</span> <span class="o">-</span> <span class="n">start_pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">end_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[:,</span> <span class="n">start_pos</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[:,</span> <span class="n">start_pos</span><span class="p">:</span><span class="o">-</span><span class="n">end_pos</span><span class="p">]</span>

            <span class="c1"># Check the difference in samples</span>
            <span class="c1"># between current signal</span>
            <span class="c1"># and desired duration</span>
            <span class="n">difference</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">duration</span>

            <span class="c1"># Expand signal if too short</span>
            <span class="c1"># and fill is requested</span>
            <span class="k">if</span> <span class="n">difference</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill</span> <span class="o">!=</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_pos</span> <span class="o">==</span> <span class="s2">&quot;right&quot;</span><span class="p">:</span>
                    <span class="n">prepend_samples</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">append_samples</span> <span class="o">=</span> <span class="o">-</span><span class="n">difference</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_pos</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                    <span class="n">prepend_samples</span> <span class="o">=</span> <span class="o">-</span><span class="n">difference</span>
                    <span class="n">append_samples</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_pos</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
                    <span class="n">prepend_samples</span><span class="p">,</span> <span class="n">append_samples</span> <span class="o">=</span> <span class="n">distribute_samples</span><span class="p">(</span><span class="o">-</span><span class="n">difference</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill</span> <span class="o">==</span> <span class="s2">&quot;zeros&quot;</span><span class="p">:</span>
                    <span class="c1"># Expand signal by zeros</span>
                    <span class="n">prepend_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">prepend_samples</span><span class="p">),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">append_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">append_samples</span><span class="p">),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill</span> <span class="o">==</span> <span class="s2">&quot;loop&quot;</span><span class="p">:</span>
                    <span class="c1"># Repeat signal in the expanded parts</span>
                    <span class="n">repetitions</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">prepend_samples</span><span class="p">,</span> <span class="n">append_samples</span><span class="p">)</span> <span class="o">/</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>
                    <span class="n">repeated_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">repetitions</span><span class="p">)</span>
                    <span class="n">prepend_array</span> <span class="o">=</span> <span class="n">repeated_array</span><span class="p">[:,</span> <span class="o">-</span><span class="n">prepend_samples</span><span class="p">:]</span>
                    <span class="n">append_array</span> <span class="o">=</span> <span class="n">repeated_array</span><span class="p">[:,</span> <span class="p">:</span><span class="n">append_samples</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">prepend_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">prepend_array</span><span class="p">,</span> <span class="n">signal</span><span class="p">],</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">append_samples</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">signal</span><span class="p">,</span> <span class="n">append_array</span><span class="p">],</span>
                        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="c1"># Set start_pos to 0 for final trim with provided duration</span>
            <span class="n">start_pos</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[:,</span> <span class="n">start_pos</span> <span class="p">:</span> <span class="n">start_pos</span> <span class="o">+</span> <span class="n">duration</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="WhiteNoiseGaussian"><a class="viewcode-back" href="../../../api/auglib.transform.WhiteNoiseGaussian.html#auglib.transform.WhiteNoiseGaussian">[docs]</a><span class="k">class</span> <span class="nc">WhiteNoiseGaussian</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Adds Gaussian white noise.</span>

<span class="sd">    Args:</span>
<span class="sd">        gain_db: gain in decibels.</span>
<span class="sd">            Ignored if ``snr_db`` is not ``None``</span>
<span class="sd">        snr_db: signal-to-noise ratio in decibels</span>
<span class="sd">        stddev: standard deviation</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Pure Gaussian white noise.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; auglib.seed(0)</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.WhiteNoiseGaussian(gain_db=-10)</span>
<span class="sd">            &gt;&gt;&gt; signal = np.zeros((1, 16000))</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-white-noise-gaussian0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-white-noise-gaussian0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        It has a flat magnitude spectrum.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audmath</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; magnitude, f = plt.mlab.magnitude_spectrum(augmented_signal[0, :], Fs=16000)</span>
<span class="sd">            &gt;&gt;&gt; # Smooth magnitude</span>
<span class="sd">            &gt;&gt;&gt; magnitude = np.convolve(magnitude, np.ones(14) / 14, mode=&quot;same&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.semilogx(f, audmath.db(magnitude), color=&quot;#e13b41&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlim([10, 10010])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylim([-75, -45])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylabel(&quot;Magnitude / dB&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlabel(&quot;Frequency / Hz&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.grid(alpha=0.4)</span>
<span class="sd">            &gt;&gt;&gt; sns.despine()</span>
<span class="sd">            &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">        Gaussian white noise added with an SNR of 10 dB to speech.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.WhiteNoiseGaussian(snr_db=10)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-white-noise-gaussian1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-white-noise-gaussian1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">gain_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">snr_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">stddev</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span> <span class="o">=</span> <span class="n">gain_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span> <span class="o">=</span> <span class="n">snr_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stddev</span> <span class="o">=</span> <span class="n">stddev</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">snr_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span><span class="p">)</span>
            <span class="c1"># For white noise we have</span>
            <span class="c1"># rms_noise_db</span>
            <span class="c1"># = 20 * log10(rms_noise)</span>
            <span class="c1"># = 10 * log10(power_noise)</span>
            <span class="c1"># = 10 * log10(stddev^2)</span>
            <span class="c1"># compare https://en.wikipedia.org/wiki/White_noise</span>
            <span class="c1">#</span>
            <span class="c1"># For short signals and low sampling rates,</span>
            <span class="c1"># rms_noise_db and hence the resulting SNR</span>
            <span class="c1"># can slightly deviate from the theoretical value.</span>
            <span class="n">noise_db</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stddev</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">signal_db</span> <span class="o">=</span> <span class="n">rms_db</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
            <span class="n">gain_db</span> <span class="o">=</span> <span class="n">get_noise_gain_from_snr</span><span class="p">(</span><span class="n">signal_db</span><span class="p">,</span> <span class="n">noise_db</span><span class="p">,</span> <span class="n">snr_db</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gain_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span><span class="p">)</span>
        <span class="n">stddev</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stddev</span><span class="p">)</span>
        <span class="n">noise_generator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">get_seed</span><span class="p">())</span>

        <span class="n">signal</span> <span class="o">+=</span> <span class="n">from_db</span><span class="p">(</span><span class="n">gain_db</span><span class="p">)</span> <span class="o">*</span> <span class="n">noise_generator</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stddev</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>


<div class="viewcode-block" id="WhiteNoiseUniform"><a class="viewcode-back" href="../../../api/auglib.transform.WhiteNoiseUniform.html#auglib.transform.WhiteNoiseUniform">[docs]</a><span class="k">class</span> <span class="nc">WhiteNoiseUniform</span><span class="p">(</span><span class="n">Base</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adds uniform white noise.</span>

<span class="sd">    Args:</span>
<span class="sd">        gain_db: gain in decibels.</span>
<span class="sd">            Ignored if ``snr_db`` is not ``None``</span>
<span class="sd">        snr_db: signal-to-noise ratio in decibels</span>
<span class="sd">        preserve_level: if ``True``</span>
<span class="sd">            the root mean square value</span>
<span class="sd">            of the augmented signal</span>
<span class="sd">            will be the same</span>
<span class="sd">            as before augmentation</span>
<span class="sd">        bypass_prob: probability to bypass the transformation</span>

<span class="sd">    Examples:</span>
<span class="sd">        Pure uniform white noise.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audplot</span>
<span class="sd">            &gt;&gt;&gt; import auglib</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; auglib.seed(0)</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.WhiteNoiseUniform(gain_db=-15)</span>
<span class="sd">            &gt;&gt;&gt; signal = np.zeros((1, 16000))</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-white-noise-uniform0.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-white-noise-uniform0.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">        It has a flat magnitude spectrum.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audmath</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt; import seaborn as sns</span>
<span class="sd">            &gt;&gt;&gt; magnitude, f = plt.mlab.magnitude_spectrum(augmented_signal[0, :], Fs=16000)</span>
<span class="sd">            &gt;&gt;&gt; # Smooth magnitude</span>
<span class="sd">            &gt;&gt;&gt; magnitude = np.convolve(magnitude, np.ones(14) / 14, mode=&quot;same&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.semilogx(f, audmath.db(magnitude), color=&quot;#e13b41&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlim([10, 10010])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylim([-75, -45])</span>
<span class="sd">            &gt;&gt;&gt; plt.ylabel(&quot;Magnitude / dB&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.xlabel(&quot;Frequency / Hz&quot;)</span>
<span class="sd">            &gt;&gt;&gt; plt.grid(alpha=0.4)</span>
<span class="sd">            &gt;&gt;&gt; sns.despine()</span>
<span class="sd">            &gt;&gt;&gt; plt.tight_layout()</span>

<span class="sd">        Uniform white noise added with an SNR of 10 dB to speech.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: True</span>

<span class="sd">            &gt;&gt;&gt; import audb</span>
<span class="sd">            &gt;&gt;&gt; import audiofile</span>
<span class="sd">            &gt;&gt;&gt; transform = auglib.transform.WhiteNoiseUniform(snr_db=10)</span>
<span class="sd">            &gt;&gt;&gt; files = audb.load_media(&quot;emodb&quot;, &quot;wav/03a01Fa.wav&quot;, version=&quot;1.4.1&quot;)</span>
<span class="sd">            &gt;&gt;&gt; signal, _ = audiofile.read(files[0])</span>
<span class="sd">            &gt;&gt;&gt; augmented_signal = transform(signal)</span>
<span class="sd">            &gt;&gt;&gt; audplot.waveform(augmented_signal)</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :context: close-figs</span>
<span class="sd">            :include-source: False</span>

<span class="sd">            audiofile.write(</span>
<span class="sd">                audeer.path(media_dir, &#39;transform-white-noise-uniform1.wav&#39;),</span>
<span class="sd">                augmented_signal,</span>
<span class="sd">                16000,</span>
<span class="sd">            )</span>

<span class="sd">        .. raw:: html</span>

<span class="sd">            &lt;p style=&quot;margin-left: 24px;&quot;&gt;</span>
<span class="sd">              &lt;audio controls src=&quot;media/transform-white-noise-uniform1.wav&quot;&gt;&lt;/audio&gt;</span>
<span class="sd">            &lt;/p&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">gain_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">snr_db</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">preserve_level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bypass_prob</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">observe</span><span class="o">.</span><span class="n">Base</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">preserve_level</span><span class="o">=</span><span class="n">preserve_level</span><span class="p">,</span>
            <span class="n">bypass_prob</span><span class="o">=</span><span class="n">bypass_prob</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span> <span class="o">=</span> <span class="n">gain_db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span> <span class="o">=</span> <span class="n">snr_db</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">signal</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sampling_rate</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">snr_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_db</span><span class="p">)</span>
            <span class="c1"># For uniform white noise we have</span>
            <span class="c1"># rms_noise_db  -4.77125 dB</span>
            <span class="c1"># deducted as the mean RMS of multiple</span>
            <span class="c1"># randomly initialised Uniform White Noises</span>
            <span class="c1"># with 0 dB as gain</span>
            <span class="c1">#</span>
            <span class="c1"># For short signals and low sampling rates,</span>
            <span class="c1"># rms_noise_db and hence the resulting SNR</span>
            <span class="c1"># can slightly deviate.</span>
            <span class="n">noise_db</span> <span class="o">=</span> <span class="o">-</span><span class="mf">4.77125</span>
            <span class="n">signal_db</span> <span class="o">=</span> <span class="n">rms_db</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
            <span class="n">gain_db</span> <span class="o">=</span> <span class="n">get_noise_gain_from_snr</span><span class="p">(</span><span class="n">signal_db</span><span class="p">,</span> <span class="n">noise_db</span><span class="p">,</span> <span class="n">snr_db</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gain_db</span> <span class="o">=</span> <span class="n">observe</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gain_db</span><span class="p">)</span>

        <span class="n">noise_generator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">get_seed</span><span class="p">())</span>

        <span class="n">signal</span> <span class="o">+=</span> <span class="n">from_db</span><span class="p">(</span><span class="n">gain_db</span><span class="p">)</span> <span class="o">*</span> <span class="n">noise_generator</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div>
    <p>
        
        
        
          Built with <a href="https://www.sphinx-doc.org/en/master/">Sphinx</a> on 2024/07/08 using the <a href="https://github.com/audeering/sphinx-audeering-theme/">audEERING theme</a>
        
    </p>
  </div>

  <div role="contentinfo">
    <p>
        
      &copy; 2019-2024 audEERING GmbH
    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  



  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/thebelab-helper.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>